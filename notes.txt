1. Intro
===================
* ES6 with Babel and Webpack has become a de-facto way to build the React applications.
* Redux created at 2015 had become a de facto Flux implementation.
* Why Redux?
  - One Store
  - Reduced Boilerplate
  - Isomorphic/Universal Friendly
  - Immutable Store
  - Hot Reloading
  - Time-travel debugging
  - Small



2. Environment Setup
===================
* Resources:
  - The official react starter kit by Cory House, called React Slingshot: https://github.com/coryhouse/react-slingshot
  - The environment setup resources for this course, a simplified version: https://github.com/coryhouse/pluralsight-redux-starter
* Target - do all of the following in one command:
  - Automated Testing (Mocha)
  - Linting (ESLint)
  - Minification (webpack)
  - Bundling (webpack)
  - JSX compilation (reactify)
  - ES6 transpilation (Babel)
  - Serving the app (Express)
  - Tying all together (npm scripts)
* Transpiling:
  - Having Babel transpiling ES6 to ES5, the Polyfills are used when some ES6 features can't be simply transpiled, e.g. array.from, set, map, promise, generators, etc.
    Babel-polyfill can polyfill all these features so that ES6 can be safely used. It is used in this course for simplicity, however, it weights a lot and the better
    alternative is to go after the individual polyfills required by the application and most of those are available as an individual npm packages.
* Hot Reloading:
  - There are multiple ways to handle hot reloading, which is likely change in the future, and this course will use babel-preset-react-hmre.
    The babel-preset-react-hmre wraps a number of other libraries and settings in a single preset that's easy to set up.
    It works by wrapping your components in a custom proxy using Babel. The proxies are classes that act just like your classes,
    but they provide hooks for injecting new implementations, so that when you hit save, your changes are applied without requiring a reload.
    Bottom line is that we are going to install babel-preset-react-hmre npm package and put a reference to it in .babelrc.
  - Warning:
    ~ Hot reloading is still experimental. There are likely to be better ways to handle this in the future.
    ~ Doesn't hot reload Functional components, unless there is a Class somewhere up hierarchy tree (there usually is).
    ~ Doesn't hot reload Container functions, like mapStateToProps.
    ~ Other options exist - React Hot Loader 3.0 is in alpha currently and it addresses those downsides. This will be the recommended approach.
* Versions:
  - Node 6.10 (can run multiple versions of node via nvm-windows)
  - React 15.0.2
  - Redux 3.5.2
  - React-router 2.4.0
  - Webpack 1.13
  - Babel 6.*
* Editors:
  - Webstorm - best ES6 support, powerful refactoring tools, autocompletion, etc.
  - Atom with 'react' (language support, indentation, snippets, auto completion, reformatting) and 'terminal-plus' (integrated terminal) packages
* Build:
  - npm scripts instead of Grunt or Gulp - bit.ly/npmvsgulp
* webpack.config.dev.js configuration options:
  - debug - enables displaying the debug informaiton.
  - devtool - a way to map the minified code sent to browser to the source code that is also sent along, so that the front-end debugging is comfortable.
  - noInfo - enables displaying the list of files the webpack is bundling.
  - entry - an array of entry points for development, which is a good way to inject middleware for things like hot reloading.
            The order is critical and an entry point for our app comes last.
  - target - the target execution environment type, which is used by bundler in order to bundle the code correctly.
  - output - specifies where the webpack whould create our dev bundle. Webpack isn't actually going to generate any physical files, but will create bundles in memory.
             We need this option to simulate the physical file's existence and have something to refer to in index.html for example.
             The real physical files will be created during the production build though.
  - devServer - mainly it specifies where are the source files that are to be bundled and served.
  - plugins - enabling additional webpack capabilities.
  - module - tells webpack what kind of file types it should handle. We could handle SaaS and LESS here also.
* .eslintrc configuration options:
  - extends - usually is extending eslint recommended settings as a baseline and augmenting them with plugins for enhanced linting for ES6 imports.
  - plugins - here we will use the React plugin to add a number of useful React-specific linting rules (prefixed with 'react/').
  - rules - linting rule preferences. 0 - off, 1 - warning, 2 - error (breaks the build).
  - parserOptions - enables ES6 and JSX.
  - env - declares the environments eslint should be aware of, i.e. to expect certain global variables.
* npm commands
  >npm install
  >npm start -s


.editorconfig
----
# editorconfig.org
root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.md]
trim_trailing_whitespace = false


.eslintrc
----
{
  "extends": [
    "eslint:recommended",
    "plugin:import/errors",
    "plugin:import/warnings"
  ],
  "plugins": [
    "react"
  ],
  "parserOptions": {
    "ecmaVersion": 6,
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "env": {
    "es6": true,
    "browser": true,
    "node": true,
    "jquery": true,
    "mocha": true
  },
  "rules": {
    "quotes": 0,
    "no-console": 1,
    "no-debugger": 1,
    "no-var": 1,
    "semi": [1, "always"],
    "no-trailing-spaces": 0,
    "eol-last": 0,
    "no-unused-vars": 0,
    "no-underscore-dangle": 0,
    "no-alert": 0,
    "no-lone-blocks": 0,
    "jsx-quotes": 1,
    "react/display-name": [ 1, {"ignoreTranspilerName": false }],
    "react/forbid-prop-types": [1, {"forbid": ["any"]}],
    "react/jsx-boolean-value": 1,
    "react/jsx-closing-bracket-location": 0,
    "react/jsx-curly-spacing": 1,
    "react/jsx-indent-props": 0,
    "react/jsx-key": 1,
    "react/jsx-max-props-per-line": 0,
    "react/jsx-no-bind": 1,
    "react/jsx-no-duplicate-props": 1,
    "react/jsx-no-literals": 0,
    "react/jsx-no-undef": 1,
    "react/jsx-pascal-case": 1,
    "react/jsx-sort-prop-types": 0,
    "react/jsx-sort-props": 0,
    "react/jsx-uses-react": 1,
    "react/jsx-uses-vars": 1,
    "react/no-danger": 1,
    "react/no-did-mount-set-state": 1,
    "react/no-did-update-set-state": 1,
    "react/no-direct-mutation-state": 1,
    "react/no-multi-comp": 1,
    "react/no-set-state": 0,
    "react/no-unknown-property": 1,
    "react/prefer-es6-class": 1,
    "react/prop-types": 1,
    "react/react-in-jsx-scope": 1,
    "react/require-extension": 1,
    "react/self-closing-comp": 1,
    "react/sort-comp": 1,
    "react/wrap-multilines": 1
  }
}


package.json
----
{
  "name": "react-redux-building-applications",
  "version": "1.0.0",
  "description": "Starter kit for React and Redux Pluralsight course by Cory House",
  "scripts": {
    "prestart": "babel-node tools/startMessage.js",
    "start": "npm-run-all --parallel test:watch open:src lint:watch",
    "open:src": "babel-node tools/srcServer.js",
    "lint": "node_modules/.bin/esw webpack.config.* src tools",
    "lint:watch": "npm run lint -- --watch",
    "test": "mocha --reporter progress tools/testSetup.js \"src/**/*.test.js\"",
    "test:watch": "npm run test -- --watch"
  },
  "author": "Aleksandr Fokin",
  "license": "MIT",
  "dependencies": {
    "babel-polyfill": "6.8.0",
    "bootstrap": "3.3.6",
    "jquery": "2.2.3",
    "react": "15.0.2",
    "react-dom": "15.0.2",
    "react-redux": "4.4.5",
    "react-router": "2.4.0",
    "react-router-redux": "4.0.4",
    "redux": "3.5.2",
    "redux-thunk": "2.0.1",
    "toastr": "2.1.2"
  },
  "devDependencies": {
    "babel-cli": "6.8.0",
    "babel-core": "6.8.0",
    "babel-loader": "6.2.4",
    "babel-plugin-react-display-name": "2.0.0",
    "babel-preset-es2015": "6.6.0",
    "babel-preset-react": "6.5.0",
    "babel-preset-react-hmre": "1.1.1",
    "babel-register": "6.8.0",
    "cheerio": "0.22.0",
    "colors": "1.1.2",
    "compression": "1.6.1",
    "cross-env": "1.0.7",
    "css-loader": "0.23.1",
    "enzyme": "2.2.0",
    "eslint": "2.9.0",
    "eslint-plugin-import": "1.6.1",
    "eslint-plugin-react": "5.0.1",
    "eslint-watch": "2.1.11",
    "eventsource-polyfill": "0.9.6",
    "expect": "1.19.0",
    "express": "4.13.4",
    "extract-text-webpack-plugin": "1.0.1",
    "file-loader": "0.8.5",
    "jsdom": "8.5.0",
    "mocha": "2.4.5",
    "nock": "8.0.0",
    "npm-run-all": "1.8.0",
    "open": "0.0.5",
    "react-addons-test-utils": "15.0.2",
    "redux-immutable-state-invariant": "1.2.3",
    "redux-mock-store": "1.0.2",
    "rimraf": "2.5.2",
    "style-loader": "0.13.1",
    "url-loader": "0.5.7",
    "webpack": "1.13.0",
    "webpack-dev-middleware": "1.6.1",
    "webpack-hot-middleware": "2.10.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/RockingChewee/react-redux-building-applications"
  }
}


webpack.config.dev.js
----
import webpack from 'webpack';
import path from 'path';

export default {
  debug: true,
  devtool: 'inline-source-map',
  noInfo: false,
  entry: [
    'eventsource-polyfill', // necessary for hot reloading with IE
    'webpack-hot-middleware/client?reload=true', //note that it reloads the page if hot module reloading fails.
    path.resolve(__dirname, 'src/index') // our application's actual entry point, has to be last
  ],
  target: 'web',
  output: {
    path: __dirname + '/dist', // Note: Physical files are only output by the production build task `npm run build`.
    publicPath: '/',
    filename: 'bundle.js'
  },
  devServer: {
    contentBase: path.resolve(__dirname, 'src')
  },
  plugins: [
    new webpack.HotModuleReplacementPlugin(), // enables to hot-replace modules without a full browser refresh
    new webpack.NoErrorsPlugin() // keeps errors from breaking our hot reloading experience
  ],
  module: {
    loaders: [
      {test: /\.js$/, include: path.join(__dirname, 'src'), loaders: ['babel']},
      {test: /(\.css)$/, loaders: ['style', 'css']}, // we could tell webpack to handle SaaS and LESS files here also
      {test: /\.eot(\?v=\d+\.\d+\.\d+)?$/, loader: 'file'}, // the following 4 instructions are necessary for the file types Bootstrap utilizes for fonts
      {test: /\.(woff|woff2)$/, loader: 'url?prefix=font/&limit=5000'},
      {test: /\.ttf(\?v=\d+\.\d+\.\d+)?$/, loader: 'url?limit=10000&mimetype=application/octet-stream'},
      {test: /\.svg(\?v=\d+\.\d+\.\d+)?$/, loader: 'url?limit=10000&mimetype=image/svg+xml'}
    ]
  }
};


.babelrc - all the mentioned presents were installed as npm modules (es2015, react, react-hmre)
----
{
  "presets": ["react", "es2015"],
  "env": {
    "development": {
      "presets": ["react-hmre"]
    }
  }
}


tools/srcServer.js
----
import express from 'express';
import webpack from 'webpack';
import path from 'path';
import config from '../webpack.config.dev';
import open from 'open';

/* eslint-disable no-console */

const port = 3000;
const app = express(); // creating instance of express
const compiler = webpack(config); // getting a compiled webpack config

app.use(require('webpack-dev-middleware')(compiler, {
  noInfo: true,
  publicPath: config.output.publicPath
}));

app.use(require('webpack-hot-middleware')(compiler));

app.get('*', function(req, res) { // since this is a one page app, we are serving index.html for all requests
  res.sendFile(path.join( __dirname, '../src/index.html'));
});

app.listen(port, function(err) {
  if (err) {
    console.log(err);
  } else {
    open(`http://localhost:${port}`);
  }
});


tools/startMessage.js
----
import colors from 'colors';

/* eslint-disable no-console */

console.log('Starting app in dev mode...'.green);


tools/testSetup.js
----
// This file is written in ES5 since it's not transpiled by Babel.
// This file does the following:
// 1. Sets Node environment variable
// 2. Registers babel for transpiling our code for testing
// 3. Disables Webpack-specific features that Mocha doesn't understand.
// 4. Requires jsdom so we can test via an in-memory DOM in Node
// 5. Sets up global vars that mimic a browser.

/* eslint-disable no-var*/

/* This setting assures the .babelrc dev config (which includes
 hot module reloading code) doesn't apply for tests.
 But also, we don't want to set it to production here for
 two reasons:
 1. You won't see any PropType validation warnings when
 code is running in prod mode.
 2. Tests will not display detailed error messages
 when running against production version code
 */
process.env.NODE_ENV = 'test';

// Register babel so that it will transpile ES6 to ES5
// before our tests run.
require('babel-register')();

// Disable webpack-specific features for tests since
// Mocha doesn't know what to do with them.
require.extensions['.css'] = function () {return null;};
require.extensions['.png'] = function () {return null;};
require.extensions['.jpg'] = function () {return null;};

// Configure JSDOM and set global variables
// to simulate a browser environment for tests.
var jsdom = require('jsdom').jsdom;

var exposedProperties = ['window', 'navigator', 'document'];

global.document = jsdom('');
global.window = document.defaultView;
Object.keys(document.defaultView).forEach((property) => {
  if (typeof global[property] === 'undefined') {
    exposedProperties.push(property);
    global[property] = document.defaultView[property];
  }
});

global.navigator = {
  userAgent: 'node.js'
};

documentRef = document;  //eslint-disable-line no-undef


src/index.html
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Pluralsight Admin</title>
  </head>
  <body>
    <h1>React and Redux in ES6 on Pluralsight</h1>
    <div id="app"></div>
    <script src="/bundle.js"></script>
  </body>
</html>


src/index.js
----
/* eslint-disable no-console */
console.log('hi');


src/index.test.js
----
import expect from 'expect';

describe('Our first test', () => {
  it('should pass', () => {
    expect(true).toEqual(true);
  });
});



3. React Component Approaches
===================

* React component creation Approaches
  - ES5 createClass
    var HelloWorld = React.createClass({
      render: function() {
        return (
          <h1>Hello World</h1>
        );
      }
    });
  - ES6 class
    class Contacts extends React.Component {
      render() {
        return (
          <h1>Hello World</h1>
        );
      }
    }
  - ES5 stateless function
    var HelloWorld = function(props) {
      return (
        <h1>Hello World</h1>
      );
    };
  - ES6 stateless function
    const HelloWorld = (props) => {
      return (
        <h1>Hello World</h1>
      );
    };
  - Many more... - http://bit.ly/react-define-component
    ~ Object.create
    ~ Mixins
    ~ Parasitic Components
    ~ StampIt

* Differences when creating React components in ES5 and ES6:

  - React components built with ES6 classes do NOT autobind automatically:

    // Works fine with ES5 createClass
    <div onClick={this.handleClick}></div>

    // Requires explicit bind with ES6 Class
    <div onClick={this.handleClick.bind(this)}></div>

    // OR for performance reasons, binding can be done in the constructor
    class Contacts extends React.Component {
      constructor(props) {
        super(props);
        // Need to change 'this' context of change handlers, as otherwise the 'this' context
        // of an input element is picked, where this.state doesn't exist
        this.handleClick = this.handleClick.bind(this);
      }
    }

  - PropTypes and Default props are declared separately, below the class definition.

  - setInitialState() isn't utilized in ES6 classes, but the initial state is set in constructor instead.

* Benefits of stateless functional components - use whenever possible:
  - No class needed
  - Avoid 'this' keyword
  - Enforced best practices - no state is handled in these components, therefore they remain pure and do not allow introducing of quick hacks.
  - High signal-to-noise ration - less code
  - Enhanced code completion / intellisense - if to destructure props in ES6 (example), then all needed data is held within a single function argument.
  - Bloated components are obvious - the function that takes a lot of parameters is a code smell.
  - Easier to understand - the components like that is a simple funciton that takes props and spits out HTML.
  - Easier to test, since we know it is just a markup.
  - Better performance - no state or lifecycle methods to worry about.

* When to use React class components over stateless functional components:
  - Use React class components when:
    ~ State - there is a need to utilize and maintain local state.
    ~ Refs - when it is needed to get a reference to the underlying DOM, since the stateless components don't actually create the component instance.
    ~ Lifecycle methods - when those hooks are needed.
    ~ Child functions - in stateless functional components each render creates a new instance of the nested function, which hurts the performance.
  - Use React stateless functional components:
    ~ Everywhere else.

* Container vs Presentational components:
  - Container components (also known as Smart, Stateful, Controller View):
    ~ have most of the smarts and least of the markup. These components can be thought of as a back-end for the front-end.
    ~ are usually stateful.
    ~ are primarily concerned with passing data and actions down to their children, usually presentation components.
    ~ have a Redux-specific code inside for dispatching Actions to the Store and connecting to the Store via connect method of React-Redux library.
    ~ typically generated by React-Redux library
  - Presentation components (also known as Dumb, Stateless, View):
    ~ are nearly all markup with little to none logic inside.
    ~ are typically stateless.
    ~ receive data and Actions they need from a container component via props.
    ~ typically know nothing about Redux, but just invoke callbacks passed down to them via props
    ~ written by hand and usually only have the render() method

* Nested Container components:
  A quote from Dan Abramov (creator of Redux)when trying to decide whether to create Container or Presentational component:
  "When you notice that some components don't use props they receive but merely forward them down, it's a good time to introduce some container components."
  This is supposed to be a criteria to create nested Container components, which is normally avoided for performance reasons.


ES6 class example:
----
import React from 'react';
class HelloWorld extends React.Component {
  constructor(props) {
    super(props);
  }
  sayHi(event) {
    alert(`Hi ${this.props.name}`);
  }
  render() {
    return (
      <div>
        <a href="#" onClick={this.sayHi.bind(this)}>Say Hi</a>
      </div>
    );
  }
}
HelloWorld.propTypes = {
  name: React.PropTypes.string.isRequired
};
export default HelloWorld;


ES6 stateless functional component example
----
import React from 'react';
const HelloWorld = (props) => {
  const sayHi = (event) => {
    alert(`Hi ${props.name}`);
  }
  return (
    <div>
      <a href="#" onClick={sayHi}>Say Hi</a>
    </div>
  );
}
HelloWorld.propTypes = {
  name: React.PropTypes.string.isRequired
};
export default HelloWorld;



4. Initial App Structure
===================
* Purpose of this module is to create app foundation:
  - Create first pages
  - Create layout
  - Configure routing
  - Setup navigation

* Hot-reloading:
  - The src/components/about/AboutPage.js could totally be a functional stateless component, however, currently there is a limitation with hot-reloading,
    which doesn't work unless somewhere at the top of the components hierarchy there is a class component.
  - HTML files are also NOT a part of the hot-reloading lifecycle.


src/components/about/AboutPage.js
----
import React from 'react';

class AboutPage extends React.Component {
  render() {
    return (
      <div>
        <h1>About</h1>
        <p>This application uses React, Redux, React Router and a variety of other helpful libraries.</p>
      </div>
    );
  }
}

export default AboutPage;


src/components/home/HomePage.js
----
import React from 'react';
import {Link} from 'react-router';

class HomePage extends React.Component {
  render() {
    return (
      <div className="jumbotron">
        <h1>Pluralsight Administration</h1>
        <p>React, Redux and React Router in ES6 for ultra-responsive web apps.</p>
        <Link to="about" className="btn btn-primary btn-lg">Learn more</Link>
      </div>
    );
  }
}

export default HomePage;


src/components/App.js
----
// This component handles the App template used on every page.
import React, {PropTypes} from 'react';
import Header from './common/Header';

class App extends React.Component {
  render() {
    return (
      <div className="container-fluid">
        <Header/>
        {/* These "children" (e.g. AboutPage, HomePage, etc.) will be passed over from the react-router
            to App component (in routes.js) and then they will be composed right here on the page. */}
        {this.props.children}
      </div>
    );
  }
}

App.propTypes = {
  children: PropTypes.object.isRequired
};

export default App;


src/routes.js
----
import React from 'react';
import { Route, IndexRoute } from 'react-router';
import App from './components/App';
import HomePage from './components/home/HomePage';
import AboutPage from './components/about/AboutPage';
import CoursesPage from './components/course/CoursesPage';

export default (
  /* Always load the App component and then pass the nested items as "children" to the App based on the routing. */
  <Route path="/" component={App}>
    {/* If someone goes to /, we will load the HomePage. */}
    <IndexRoute component={HomePage} />
    <Route path="courses" component={CoursesPage} />
    <Route path="about" component={AboutPage} />
  </Route>
);


src/index.js
----
import 'babel-polyfill';
import React from 'react';
import { render } from 'react-dom';
import { Router, browserHistory } from 'react-router';
import routes from './routes';
import './styles/styles.css'; //Webpack can import CSS files too!
import '../node_modules/bootstrap/dist/css/bootstrap.min.css';

render(
  <Router history={browserHistory} routes={routes} />,
  document.getElementById('app')
);


src/styles/styles.css
----
/* Styles */
#app {
  font: 14px 'Helvetica Neue', Helvetica, Arial, sans-serif;
  color: #4d4d4d;
  min-width: 550px;
  max-width: 850px;
  margin: 0 auto;
}

a.active {
  color: orange;
}

nav {
  padding-top: 20px;
}


src/index.html
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Pluralsight Admin</title>
  </head>
  <body>
    <div id="app"></div>
    <script src="/bundle.js"></script>
  </body>
</html>


src/components/common/Header.js
----
import React, {PropTypes} from 'react';
import { Link, IndexLink } from 'react-router';

const Header = () => {
  return (
    <nav>
      {/* The class value of activeClassName styles the currently selected anchor accordingly. */}
      <IndexLink to="/" activeClassName="active">Home</IndexLink>
      {" | "}
      <Link to="/courses" activeClassName="active">Courses</Link>
      {" | "}
      <Link to="/about" activeClassName="active">About</Link>
    </nav>
  );
};

export default Header;


src/components/course/CoursesPage.js
----
import React, {PropTypes} from 'react';

class CoursesPage extends React.Component {
  render() {
    return (
      <div>
        <h1>Courses</h1>
      </div>
    );
  }
}

export default CoursesPage;



5. Intro to Redux
===================

* Simple setup ------------ Vanilla JS --- jQuery --- React --- React + Redux ----------> Complex setup

* When to use Redux:
  - Complex data flows, i.e. not for static data
  - Inter-component communication, when same data is used in two components that have no parent-child relation
  - Application has non-hierarchical data
  - Application offers an increasing number of actions

* Typical Redux use case:
  Given 2 React components with no parent-child relation, one of the components dispatches an Action to change the data.
  The Centralized Store captures this Action and immediately notifies both components of the data change.

* Redux: 3 core principles:
  - Application state is placed in a single immutable store.
  - The only way to mutate state is to emit an Action, e.g. click on a specific submit button.
  - State is changed by pure functions, called Reducers. Reducer is a function that accepts the current state in an aciton and returns a new state.

* Flux and Redux side by side comparison:
  Flux:                                                          | Redux:
  ---------------------------------------------------------------+----------------------------------------------------------------------------
  Unidirectional data flow - data flows down, actions flow up    | Unidirectional data flow - data flows down, actions flow up
  Actions - describes user intent                                | Actions - describes user intent
  Stores contain state and change logic                          | Store contains state, but the change logic specified in Reducers
  Multiple Stores                                                | Single Store
  Flat and disconnected multiple Stores                          | Single Store with hierarchical (nested) Reducers
  Singleton Dispatcher in a center of an application             | No Dispatcher, where Actions are passed down to the Reducers directly
  React components subscribe to Stores (OnChange & EventEmitter) | Container components utilize connect method of React-Redux library
  State is manipulated directly, i.e. it is mutable              | State is immutable, i.e. a copy of new State is returned from Reducers

* Flux vs Redux flows:
  - Flux flow: ------ React component ----> Action ----> Dispatcher ----> Store ----> React component ------->
    When Actions are triggered, Stores are notified by Dispatcher (singleton). Stores are explicitly connected to Dispatcher via EventEmitter.

  - Redux flow: ----- React component ----> Action ----> Store ----> Reducers ----> Store ----> React component ------->
    ~ Action - an object with a 'type' and some data. {type: RATE_COURSE, rating: 5}
    ~ Reducer - instead of a Dispatcher, Redux relies on pure functions called Reducers, which handle Actions:
      function appReducer(state = defaultState, action) {
        switch (action.type) {
          case RATE_COURSE:
          // return new state
        }
      }
    ~ Store - updated once the new state is returned from a Reducer. Since Stores are immutable in Redux, the Reducers return a new update copy of a
              state, which updates the Store.
    ~ React component - connected to the Store using React-Redux lib.



6. Actions, Store and Reducers
===================
* Actions
  - Action Creator example:
    rateCourse(rating) {
      return { type: RATE_COURSE, rating: 5 };
    }
  - Action Creators are typically named after the Actions they create, e.g. the name of the Action Creator for the RATE_COURSE action is 'rateCourse'.
  - An Action must have 'type' property and the rest of its shape is up to the developer.
  - A 'rating' property could be anything that is serializable to JSON, i.e. a complex object, simple number, boolean, etc.
    The only thing 'rating' couldn't be is a function or a Promise.

* Store
  - In Redux, Store is created by calling createStore in the application's entry point:
    let store = createStore(reducer);
  - Unlike in Flux, in Redux Stores only Store data and the logic to manipulate the data is specifed in Reducers.
  - Having a single Store (single source of truth) makes the application easier to manage and understand.
  - Redux Store API is very simple, i.e. the Store can:
    ~ store.dispatch(action)
    ~ store.subscrbe(listener)
    ~ store.getState()
    ~ replaceReducer(nextReducer) - is useful to support hot-reloading
  - There is no API for changing data in the Store. Only Actions can change state via Reducers.

* Mutability & Immutability
  - Mutability
     ~ JavaScript types: Objects, Arrays, Functions
     ~ Example:
       state = {
         name: 'Cory House',
         role: 'author'
       }
       state.role = 'admin';
       return state;
  - Immutability
    ~ JavaScript types: Number, String, Boolean, Undefined, null
    ~ Example:
      state = {
        name: 'Cory House',
        role: 'author'
      }
      return state = {
        name: 'Cory House',
        role: 'admin'
      };

* Why is state made immutable in Redux:
  - Clarity - when state is updated, it is clear that it was done by a Reducer.
  - Performance - to know if the state has changed, instead of checking the individual properties, it is more efficient to check state like this:
                  if (prevStoreState !== storeState) { ... }
                  This comparison is used to determine when to notify React components of the state changes to trigger shouldComponentUpdate().
  - Amazing Debugging - a powerful way to see how the application state is changing over time:
                        Time-travel debugging, Undo/Redo, Turn off individual Actions, Play interactions back.

* Ways to handling immutability (cloning):
  - ES6: Object.assign, Spread operator
  - ES5: Lodash merge, Lodash extend, Object-assign npm package
  - Libraries: react-addons-update, Immutable.js

* Three different approaches to enforce immutability:
  - Trust your team - hope that everyone remembers to keep state immutable.
  - Install 'redux-immutable-state-invariant' and use it in your Store file - use only in development!!!
  - Use Immutable.js

* Reducers
  - To change the Store, the Action is dispatched that is ultimately handled by a Reducer.
  - Reducers take state and an Action and return a new state:
    function myReducer(state, action) { // OR alternatively in ES6: (state, action) => state
      switch (action.type) {
        case 'INCREMENT_COUNTER':
          return Object.assign({}, state, {counter: state.counter + 1}); // returns new state based on action passed
      }
    }
  - Reducers must be pure funcitons and produce no side effects - calling it with the same arguments always returns the same predictable value.
  - Forbidden in Reducers:
    ~ Mutate arguments
    ~ Perform side effects, like API calls and routing transitions
    ~ Call non-pure functions, like date.now() or math.random()
  - Reducers can be nested:
    In Flux there can be multiple Stores, each one holding a different area of domain data. The downside is that one store needs to wait before
    the other one updates. This isn't necessary in Redux because the separation between data domains is achieved by splitting a single reducer
    into multiple smaller ones. It is technically possible to create multiple Stores in Redux, but it is not recommended and only useful rarely.
  - All Reducers are called on EACH dispatch - it is important for the Reducers to return the untouched state if no switch case matched.
    Each Reducer only handles its slice of state.
  - Redux FAQ: "Write independent small reducer functions that are each responsible for updates to a specific slice of state.
    We call this pattern "reducer composition". A given action could be handled by all, some, or none of them."
    In other there shouldn't always be a 1:1 mapping between Reducers and Actions.



7. Connecting React to Redux
===================
* React-Redux is a companion library for Redux, that connects the React Router components to Redux.
* Since Redux is just a way to handle state, it can be used with other libraries different from React: Angular, Ember, jQuery or vanilla JavaScript.
* React-Redux ties the React components with Redux and consists of 2 core items:
  - Provider component:
    ~ utilized at the application's root
    ~ wraps the entire application
    ~ attaches application to the store
    ~ makes the store available to all container components in the application without having to pass it explicitly
    ~ example:
      <Provider store={store}>
        <App/>
      </Provider>
  - Connect function:
    ~ wraps the React component so it's connected to the Redux Store
    ~ declares what parts of the store we'd like atached to our component as props via mapStateToProps() function as argument
    ~ declares what Actions we want to expose on props via mapDispatchToProps() function as argument
    ~ example:
      export default connect(
        mapStateToProps,
        mapDispatchToProps
      )(AuthorPage);

* Connecting React components to Stores in Flux - boiler plate

  componentWillMount() {
    AuthorStore.addChangeListener(this.onChange);
  }
  componentWillUnmount() {
    AuthorStore.removeChangeListener(this.onChange)
  }
  onChange() {
    this.setState({ authors: AuthorStore.getAll() });
  }

* Connecting React components to Stores in Redux

  function mapStateToProps(state, ownProps) {
    return {appState: state.authorReducer}; // in the React component the author slice of state is now accessible via this.props.appState.xxx
  }
  function mapDispatchToProps(dispatch) {
    return {
      actions: bindActionCreators(actions, dispatch) // returns a callback props that will be passed down
    };
  }
  export default connect(  // both parameter functions are optional
    mapStateToProps,
    mapDispatchToProps
  )(AuthorPage);

  - mapStateToProps()
    ~ Specifies the part of Store to expose to the component via props.
    ~ A way for the React component to subscribe to the Redux Store updates.
    ~ Each time relevant part of Redux Store updates, mapStateToProps of the current React component is called.
      If something expensive is happening in mapStateToProps, then Memoizing can be used to improve the performance.
      Memoizing is like a cache for the function calls, which is used when the function is invoked repeatedly with the same parameters.

  - mapDispatchToProps()
    ~ Specifies the Actions to expose to the React component as props.
    ~ Receives 'dispatch' and returns the callback props to be passed down.
    ~ If mapDispatchToProps is omitted in the connect() invocation, then connect() adds a 'dispatch' function as a property in this.props.
    ~ The bindActionCreators() function is a part of Redux.
    ~ 3 ways of passing Actions down to components using Redux:

      1. Ignore passing mapDispatchToProps() and use dispatch() to call action creators:

         // In component...
         this.props.dispatch(loadCourses());

      2. Manually wrap action creators - in comparison with Option 1, this one keeps the calls in the actual component shorter:

         function mapDispatchToProps(dispatch) {
           return {
             loadCourses: () => {
               dispatch(loadCourses());
             },
             createCourse: (course) => {
               dispatch(createCourse(course));
             }
           };
         }

         // In component...
         this.props.loadCourses();

      3. Use bindActionCreators() - basically does what is done in Option 2 automatically:

         function mapDispatchToProps(dispatch) {
           return {
             actions: bindActionCreators(actions, dispatch)
           };
         }

         // In component...
         this.props.actions.loadCourses();

  - Advantages of Redux
    ~ No manual subscribe/unsubscribe.
    ~ No lifecycle methods required.
    ~ Declare the wanted subset of state to expose.
    ~ Enhanced performance.

* Chat with Redux
  - React       - Hey CourseAction, someone clicked this "Save Course" button.
  - Action      - Thanks React! I will dispatch an Action so Reducers that care can update state.
  - Reducer     - Ah, thanks Action. I see you passed me the current state and the Action to perform. I'll make a new copy of the state and return it.
  - Store       - Thanks for updating the state, Reducer. I'll make sure that all connected components are aware.
  - React-Redux - Woah, thanks for the new data, Store. I'll now intelligently determine if I should tell React about this change so that it only has
                  to bother with updating the UI when necessary.
  - React       - Ooo! Shiny new data has been passed down via props from the store! I'll update the UI to reflect this!



8. Redux Flow
===================

* Code flow, i.e. what to code first and to what to proceed next:
  - src/actions/courseActions.js - createCourse()
  - src/reducers/courseReducer.js - case 'CREATE_COURSE'
  - src/components/course/CoursesPage.js - mapStateToProps()
  - src/components/course/CoursesPage.js - render()

* Typical ES6 React class Container component structure review when using Redux:
  - Constructor is used for setting the initial state and calling bind functions.
  - Child functions that are called by render(), usually 'change' event handlers.
  - render() function that usually calls a View component and supplies data and event handlers to it via props.
  - Provide PropTypes below the ES6 react class declaration.
  - Redux connect related functions - mapStateToProps() declaration, mapDispatchToProps() declaration, connect() invocation.


src/components/course/CoursesPage.js
----
import React, {PropTypes} from 'react';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import * as courseActions from '../../actions/courseActions';

class CoursesPage extends React.Component {

  constructor(props, context) {
    super(props, context);
    this.state = {
      course: { title: '' }
    };
    // Need to change 'this' context of change handlers, as otherwise the 'this' context
    // of an input element is picked, where this.state doesn't exist
    this.onTitleChange = this.onTitleChange.bind(this);
    this.onClickSave = this.onClickSave.bind(this);
  }

  onTitleChange(event) {
    const course = this.state.course;
    course.title = event.target.value;
    this.setState({course: course});
  }

  onClickSave() {
    this.props.actions.createCourse(this.state.course);
  }

  courseRow(course, index) {
    return <div key={index}>{course.title}</div>;
  }

  render() {
    return (
      <div>
        <h1>Courses</h1>
        {this.props.courses.map(this.courseRow)}
        <h2>Add Course</h2>
        <input
          type="text"
          onChange={this.onTitleChange}
          value={this.state.course.title} />
        <input
          type="submit"
          value="Save"
          onClick={this.onClickSave} />
      </div>
    );
  }
}

CoursesPage.propTypes = {
  courses: PropTypes.array.isRequired,
  actions: PropTypes.object.isRequired
};

function mapStateToProps(state, ownProps) {
  return {
    courses: state.courses // the name 'courses' of state depends on how the courseReducer is referenced to in rootReducer, i.e. src/reducers/index.js
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: bindActionCreators(courseActions, dispatch)
  };
}

// connect(mapStateToProps, mapDispatchToProps) returns a function, which is invoked with CoursesPage argument
export default connect(mapStateToProps, mapDispatchToProps)(CoursesPage);


src/actions/courseActions.js
----
import * as types from './actionTypes';

export function createCourse(course) {
  return { type: types.CREATE_COURSE, course }; // in ES5 the Object declaration would look like { type: 'CREATE_COURSE', course: course }
}


src/reducers/courseReducer.js
----
import * as types from '../actions/actionTypes';

export default function courseReducer(state = [], action) { // this slice of 'state' will be an array of courses
  switch (action.type) {
    case types.CREATE_COURSE:
      // all the 'state' array elements are picked and defined here inline, which returns a new instance of 'state' array
      // and a new array element is added to the end
      return [...state, Object.assign({}, action.course)];
    default:
      return state;
  }
}


src/reducers/index.js
----
import {combineReducers} from 'redux';
import courses from './courseReducer';

const rootReducer = combineReducers({
  courses // in ES5 this would look like courses: courses; by this name this reducer will be reachable, i.e. this.state.courses
});

export default rootReducer;


src/store/configureStore.js
----
import {createStore, applyMiddleware} from 'redux';
import rootReducer from '../reducers';
import reduxImmutableStateInvariant from 'redux-immutable-state-invariant'; // enforces immutability

export default function configureStore(initialState) {
  return createStore(
    rootReducer,
    initialState,
    applyMiddleware(reduxImmutableStateInvariant())
  );
}


src/index.js
----
import 'babel-polyfill';
import React from 'react';
import { render } from 'react-dom';
import configureStore from './store/configureStore';
import {Provider} from 'react-redux';
import { Router, browserHistory } from 'react-router';
import routes from './routes';
import './styles/styles.css'; //Webpack can import CSS files too!
import '../node_modules/bootstrap/dist/css/bootstrap.min.css';

// If we wanted to rehydrate our store with some initial state passed down from the server, we could supply it to the configureStore()
const store = configureStore();

render(
  <Provider store={store}>
    <Router history={browserHistory} routes={routes} />
  </Provider>,
  document.getElementById('app')
);


src/actions/actionTypes.js
----
export const CREATE_COURSE = 'CREATE_COURSE';



9. Async in Redux
===================
* Mock API advantages:
  - Start the development immediately, before the real API exists. Just need to agree on interfaces.
  - Independence - front-end and back-end teams don't have to move at the same pace.
  - Backup plan, if real API is broken for the time being.
  - Ultra-fast - the development is not hampered by slow unreliable API calls.
  - Controlled slowness of test by using setTimeout().
  - Aids automated testing.
  - Point to real API later.

* In Flux, the API calls are made in Actions, however, in Redux actions are synchronous and must return an object.

* Redux Async libraries:
  - redux-thunk - allows to return functions from the action creators instead of objects. Most popular, used in this course.
  - redux-promise - a new alternative middleware library (least popular) that uses Flux standard actions to bring some clear conventions to async calls.
  - redux-saga - uses ES6 generators and offers an impressive amount of power with a rich domain-specific language for dealing with asynchrony.

* Comparison:
  Thunks                              | Sagas
  ------------------------------------+--------------------------------------------
  Wraps async operation in a function | Async operations are handled via generators
  Clunky to test, have to mock API    | Easy to test
  Easy to learn                       | Hard to learn (generators and a large API)

* Redux-thunk
  Normally, we can only return objects from action creators, but with redux-thunk we return a function instead, which in turn calls another action creator.
  So instead of dispatching an Action created via action creator, we dispatch a nested function as a callback that is being processed by the Store middleware.
  This function calls an API and upon the response is received - dispatches another Action the regular way.

  export function deleteAuthor(authorId) {
    return dispatch => { // this is a Thunk and it returns a function that is handled by the Redux store middleware afterwards
      return AuthorApi.deleteAuthor(authorId).then(() => {
        dispatch(deleteAuthorSuccess(authorId)); // calling a regular action creator called deleteAuthorSuccess() once the response is received from an API call
      }).catch(handleError);
    };
  }

  Note: In computer science, a 'thunk' is a function that wraps an expresion in order to delay its evaluation.


src/api/mockAuthorApi.js
----
import delay from './delay';

// This file mocks a web API by working with the hard-coded data below.
// It uses setTimeout to simulate the delay of an AJAX call.
// All calls return promises.
const authors = [
  {
    id: 'cory-house',
    firstName: 'Cory',
    lastName: 'House'
  },
  {
    id: 'scott-allen',
    firstName: 'Scott',
    lastName: 'Allen'
  },
  {
    id: 'dan-wahlin',
    firstName: 'Dan',
    lastName: 'Wahlin'
  }
];

//This would be performed on the server in a real app. Just stubbing in.
const generateId = (author) => {
  return author.firstName.toLowerCase() + '-' + author.lastName.toLowerCase();
};

class AuthorApi {
  static getAllAuthors() {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve(Object.assign([], authors));
      }, delay);
    });
  }

  static saveAuthor(author) {
    author = Object.assign({}, author); // to avoid manipulating object passed in.
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        // Simulate server-side validation
        const minAuthorNameLength = 3;
        if (author.firstName.length < minAuthorNameLength) {
          reject(`First Name must be at least ${minAuthorNameLength} characters.`);
        }

        if (author.lastName.length < minAuthorNameLength) {
          reject(`Last Name must be at least ${minAuthorNameLength} characters.`);
        }

        if (author.id) {
          const existingAuthorIndex = authors.findIndex(a => a.id == author.id);
          authors.splice(existingAuthorIndex, 1, author);
        } else {
          //Just simulating creation here.
          //The server would generate ids for new authors in a real app.
          //Cloning so copy returned is passed by value rather than by reference.
          author.id = generateId(author);
          authors.push(author);
        }

        resolve(author);
      }, delay);
    });
  }

  static deleteAuthor(authorId) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        const indexOfAuthorToDelete = authors.findIndex(author => {
          return author.authorId == authorId;
        });
        authors.splice(indexOfAuthorToDelete, 1);
        resolve();
      }, delay);
    });
  }
}

export default AuthorApi;


src/api/mockCourseApi.js
----
import delay from './delay';

// This file mocks a web API by working with the hard-coded data below.
// It uses setTimeout to simulate the delay of an AJAX call.
// All calls return promises.
const courses = [
  {
    id: "react-creating-reusable-components",
    title: "Creating Reusable React Components",
    watchHref: "http://pluralsight.com/courses/react-creating-reusable-components",
    authorId: "cory-house",
    length: "6:20",
    category: "JavaScript"
  },
  {
    id: "react-flux-building-applications",
    title: "Building Applications in React and Flux",
    watchHref: "http://www.pluralsight.com/courses/react-flux-building-applications",
    authorId: "cory-house",
    length: "5:08",
    category: "JavaScript"
  },
  {
    id: "clean-code",
    title: "Clean Code: Writing Code for Humans",
    watchHref: "http://www.pluralsight.com/courses/writing-clean-code-humans",
    authorId: "cory-house",
    length: "3:10",
    category: "Software Practices"
  },
  {
    id: "architecture",
    title: "Architecting Applications for the Real World",
    watchHref: "http://www.pluralsight.com/courses/architecting-applications-dotnet",
    authorId: "cory-house",
    length: "2:52",
    category: "Software Architecture"
  },
  {
    id: "career-reboot-for-developer-mind",
    title: "Becoming an Outlier: Reprogramming the Developer Mind",
    watchHref: "http://www.pluralsight.com/courses/career-reboot-for-developer-mind",
    authorId: "cory-house",
    length: "2:30",
    category: "Career"
  },
  {
    id: "web-components-shadow-dom",
    title: "Web Component Fundamentals",
    watchHref: "http://www.pluralsight.com/courses/web-components-shadow-dom",
    authorId: "cory-house",
    length: "5:10",
    category: "HTML5"
  }
];

function replaceAll(str, find, replace) {
  return str.replace(new RegExp(find, 'g'), replace);
}

//This would be performed on the server in a real app. Just stubbing in.
const generateId = (course) => {
  return replaceAll(course.title, ' ', '-');
};

class CourseApi {
  static getAllCourses() {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve(Object.assign([], courses));
      }, delay);
    });
  }

  static saveCourse(course) {
    course = Object.assign({}, course); // to avoid manipulating object passed in.
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        // Simulate server-side validation
        const minCourseTitleLength = 1;
        if (course.title.length < minCourseTitleLength) {
          reject(`Title must be at least ${minCourseTitleLength} characters.`);
        }

        if (course.id) {
          const existingCourseIndex = courses.findIndex(a => a.id == course.id);
          courses.splice(existingCourseIndex, 1, course);
        } else {
          //Just simulating creation here.
          //The server would generate ids and watchHref's for new courses in a real app.
          //Cloning so copy returned is passed by value rather than by reference.
          course.id = generateId(course);
          course.watchHref = `http://www.pluralsight.com/courses/${course.id}`;
          courses.push(course);
        }

        resolve(course);
      }, delay);
    });
  }

  static deleteCourse(courseId) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        const indexOfCourseToDelete = courses.findIndex(course => {
          return course.courseId == courseId;
        });
        courses.splice(indexOfCourseToDelete, 1);
        resolve();
      }, delay);
    });
  }
}

export default CourseApi;


src/api/delay.js
----
export default 1000;


src/components/course/CoursesPage.js
----
import React, {PropTypes} from 'react';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import * as courseActions from '../../actions/courseActions';
import CourseList from './CourseList';

class CoursesPage extends React.Component {

  constructor(props, context) {
    super(props, context);
  }

  courseRow(course, index) {
    return <div key={index}>{course.title}</div>;
  }

  render() {
    const {courses} = this.props; // in ES5 this would look like as: var courses = this.props.courses;
    return (
      <div>
        <h1>Courses</h1>
        <CourseList courses={courses}/> {/* could pass {this.props.courses} also */}
      </div>
    );
  }
}

CoursesPage.propTypes = {
  courses: PropTypes.array.isRequired,
  actions: PropTypes.object.isRequired
};

function mapStateToProps(state, ownProps) {
  return {
    courses: state.courses // the name 'courses' of state depends on how the courseReducer is referenced to in rootReducer, i.e. src/reducers/index.js
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: bindActionCreators(courseActions, dispatch)
  };
}

// connect(mapStateToProps, mapDispatchToProps) returns a function, which is invoked with CoursesPage argument
export default connect(mapStateToProps, mapDispatchToProps)(CoursesPage);


src/store/configureStore.js
----
import {createStore, applyMiddleware} from 'redux';
import rootReducer from '../reducers';
import reduxImmutableStateInvariant from 'redux-immutable-state-invariant'; // enforces immutability
import thunk from 'redux-thunk';

export default function configureStore(initialState) {
  return createStore(
    rootReducer,
    initialState,
    applyMiddleware(thunk, reduxImmutableStateInvariant())
  );
}


src/actions/courseActions.js
----
import * as types from './actionTypes';
import courseApi from '../api/mockCourseApi';

export function loadCoursesSuccess(courses) {
  return { type: types.LOAD_COURSES_SUCCESS, courses }; // in ES5 the Object declaration would look like { type: types.LOAD_COURSES_SUCCESS, courses: courses }
}

// We're making an async call to an API, so we'll want to handle the promise and then dispatch an action when the promise is resolved.
export function loadCourses() {
    return function(dispatch) { // this wrapper funciton will exist in every one of our thunks
      return courseApi.getAllCourses().then(courses => { // getAllCourses() returns a promise
        dispatch(loadCoursesSuccess(courses));
      }).catch(error => {
        throw(error);
      });
    };
}


src/actions/actionTypes.js
----
export const LOAD_COURSES_SUCCESS = 'LOAD_COURSES_SUCCESS';


src/reducers/courseReducer.js
----
import * as types from '../actions/actionTypes';

export default function courseReducer(state = [], action) { // this slice of 'state' will be an array of courses
  switch (action.type) {
    case types.LOAD_COURSES_SUCCESS:
      return action.courses;
    default:
      return state;
  }
}


src/index.js
----
import 'babel-polyfill';
import React from 'react';
import { render } from 'react-dom';
import configureStore from './store/configureStore';
import {Provider} from 'react-redux';
import { Router, browserHistory } from 'react-router';
import routes from './routes';
import {loadCourses} from './actions/courseActions';
import './styles/styles.css'; //Webpack can import CSS files too!
import '../node_modules/bootstrap/dist/css/bootstrap.min.css';

// If we wanted to rehydrate our store with some initial state passed down from the server, we could supply it to the configureStore()
const store = configureStore();
// Once the Store is configured, we can dispatch Actions against the Store
store.dispatch(loadCourses());

render(
  <Provider store={store}>
    <Router history={browserHistory} routes={routes} />
  </Provider>,
  document.getElementById('app')
);


src/components/course/CourseList.js
----
import React, {PropTypes} from 'react';
import CourseListRow from './CourseListRow';

const CourseList = ({courses}) => {
  return (
    <table className="table">
      <thead>
      <tr>
        <th>&nbsp;</th>
        <th>Title</th>
        <th>Author</th>
        <th>Category</th>
        <th>Length</th>
      </tr>
      </thead>
      <tbody>
      {courses.map(course =>
        <CourseListRow key={course.id} course={course}/>
      )}
      </tbody>
    </table>
  );
};

CourseList.propTypes = {
  courses: PropTypes.array.isRequired
};

export default CourseList;


src/components/course/CourseListRow.js
----
import React, {PropTypes} from 'react';
import {Link} from 'react-router';

const CourseListRow = ({course}) => {
  return (
    <tr>
      <td><a href={course.watchHref} target="_blank">Watch</a></td>
      <td><Link to={'/course/' + course.id}>{course.title}</Link></td>
      <td>{course.authorId}</td>
      <td>{course.category}</td>
      <td>{course.length}</td>
    </tr>
  );
};

CourseListRow.propTypes = {
  course: PropTypes.object.isRequired
};

export default CourseListRow;



10. Async Writes in Redux
===================

src/components/course/ManageCoursePage.js
----
import React, { PropTypes } from 'react';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import * as courseActions from '../../actions/courseActions';
import CourseForm from './CourseForm';

export class ManageCoursePage extends React.Component {
  constructor(props, context) {
    super(props, context);

    // Setting initial LOCAL (not Redux) state
    // Constructor specific: 'this' reference can be omitted; can change state directly, i.e. without calling this.setState()
    this.state = {
      course: Object.assign({}, this.props.course), // this.props.course are coming in from the component higher in hierarchy
      errors: {}
    };

    // Need to change 'this' context of change handlers, as otherwise the 'this' context
    // of an input element is picked, where this.state doesn't exist.
    this.updateCourseState = this.updateCourseState.bind(this);
    this.saveCourse = this.saveCourse.bind(this);
  }

  // This lifecycle function is invoked each time the props are updated.
  // This way the course data still gets populated after the page refresh.
  componentWillReceiveProps(nextProps) {
    if (this.props.course.id != nextProps.course.id) { // sometimes React doesn't know for sure whether props have changed, so it runs this method for safety
      // Necessary to populate form when existing course is loaded directly.
      this.setState({ course: Object.assign({}, nextProps.course) });
    }
  }

  // A single change handler for all our form fields
  updateCourseState(event) {
    const field = event.target.name;
    let course = Object.assign({}, this.state.course); // avoiding mutating the state
    course[field] = event.target.value;
    return this.setState({ course: course });
  }

  saveCourse(event) {
    event.preventDefault();
    this.props.actions.saveCourse(this.state.course);
    // the this.context.router was pulled in by declaring static object ManageCoursePage.contextTypes
    this.context.router.push('/courses'); // an alternative to browserHistory.push("/courses");
  }

  render() {
    return (
      // Here 'authors' object is returned as a property via mapStateToProps().
      // this.state.course and this.state.errors are both part of the LOCAL component state and have nothing to do with Redux.
      <CourseForm
        allAuthors={this.props.authors}
        onChange={this.updateCourseState}
        onSave={this.saveCourse}
        course={this.state.course}
        errors={this.state.errors}
      />
    );
  }
}

ManageCoursePage.propTypes = {
  course: PropTypes.object.isRequired,
  authors: PropTypes.array.isRequired,
  actions: PropTypes.object.isRequired
};

// Pull in the React Router context so router is available on this.context.router (used in saveCourse())
// 'context' is a global variable that library authors use, but we as library consumers should avoid.
ManageCoursePage.contextTypes = {
  router: PropTypes.object
};

function getCourseById(courses, id) {
  const course = courses.filter(course => course.id == id);
  if (course.length) {
    return course[0]; // since filter returns an array, have to grab the first element
  } else {
    return null;
  }
}

function mapStateToProps(state, ownProps) { // 'ownProps' is a reference to our component's props

  // The Redux state is passed as an argument to this funciton and we can access it.

  const courseId = ownProps.params.id; // from the route path `/course/:id` at routes.js that the component itself has the access to (it is not in Redux)

  let course = { id: '', watchRef: '', title: '', authorId: '', length: '', category: '' };
  if (courseId && state.courses.length > 0) {
    course = getCourseById(state.courses, courseId);
  }

  // We have the this.state.authors set here (populated in index.js), but the shape isn't the one we need.
  // The SelectInput component accepts the data in value:text format, so we're formatting it here.
  const authorsFormattedForDropdown = state.authors.map(author => {
    return {
      value: author.id,
      text: author.firstName + ' ' + author.lastName
    };
  });

  // Here we are shaping the Redux store data to be available via props to this component.
  return {
    course: course,
    authors: authorsFormattedForDropdown // the Redux Store still contains the unformatted author list,
    // but the formatted one is passed down via props over to this component
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: bindActionCreators(courseActions, dispatch)
  };
}

export default connect(mapStateToProps, mapDispatchToProps)(ManageCoursePage);


src/routes.js
----
import React from 'react';
import { Route, IndexRoute } from 'react-router';
import App from './components/App';
import HomePage from './components/home/HomePage';
import AboutPage from './components/about/AboutPage';
import CoursesPage from './components/course/CoursesPage';
import ManageCoursePage from './components/course/ManageCoursePage'; //eslint-disable-line import/no-named-as-default

export default (
  /* Always load the App component and then pass the nested items as "children" to the App based on the routing. */
  <Route path="/" component={App}>
    {/* If someone goes to /, we will load the HomePage. */}
    <IndexRoute component={HomePage} />
    <Route path="courses" component={CoursesPage} />
    <Route path="course" component={ManageCoursePage} />
    <Route path="course/:id" component={ManageCoursePage} />
    <Route path="about" component={AboutPage} />
  </Route>
);


scr/components/course/CourseForm.js
----
import React from 'react';
import TextInput from '../common/TextInput';
import SelectInput from '../common/SelectInput';

const CourseForm = ({course, allAuthors, onSave, onChange, saving, errors}) => {
  return (
    <form>
      <h1>Manage Course</h1>
      <TextInput
        name="title"
        label="Title"
        value={course.title}
        onChange={onChange}
        error={errors.title}/>

      <SelectInput
        name="authorId"
        label="Author"
        value={course.authorId}
        defaultOption="Select Author"
        options={allAuthors}
        onChange={onChange}
        error={errors.authorId}/>

      <TextInput
        name="category"
        label="Category"
        value={course.category}
        onChange={onChange}
        error={errors.category}/>

      <TextInput
        name="length"
        label="Length"
        value={course.length}
        onChange={onChange}
        error={errors.length}/>

      <input
        type="submit"
        disabled={saving}
        value={saving ? 'Saving...' : 'Save'}
        className="btn btn-primary"
        onClick={onSave}/>
    </form>
  );
};

CourseForm.propTypes = {
  course: React.PropTypes.object.isRequired,
  allAuthors: React.PropTypes.array,
  onSave: React.PropTypes.func.isRequired,
  onChange: React.PropTypes.func.isRequired,
  saving: React.PropTypes.bool,
  errors: React.PropTypes.object
};

export default CourseForm;


src/components/common/TextInput.js
----
import React, {PropTypes} from 'react';

const TextInput = ({name, label, onChange, placeholder, value, error}) => {
  let wrapperClass = 'form-group';
  if (error && error.length > 0) {
    wrapperClass += " " + 'has-error';
  }

  return (
    <div className={wrapperClass}>
      <label htmlFor={name}>{label}</label>
      <div className="field">
        <input
          type="text"
          name={name}
          className="form-control"
          placeholder={placeholder}
          value={value}
          onChange={onChange}/>
        {error && <div className="alert alert-danger">{error}</div>}
      </div>
    </div>
  );
};

TextInput.propTypes = {
  name: PropTypes.string.isRequired,
  label: PropTypes.string.isRequired,
  onChange: PropTypes.func.isRequired,
  placeholder: PropTypes.string,
  value: PropTypes.string,
  error: PropTypes.string
};

export default TextInput;


src/components/common/SelectInput.js
----
import React, {PropTypes} from 'react';

const SelectInput = ({name, label, onChange, defaultOption, value, error, options}) => {
  return (
    <div className="form-group">
      <label htmlFor={name}>{label}</label>
      <div className="field">
        {/* Note, value is set here rather than on the option - docs: https://facebook.github.io/react/docs/forms.html */}
        <select
          name={name}
          value={value}
          onChange={onChange}
          className="form-control">
          <option value="">{defaultOption}</option>
          {options.map((option) => {
            return <option key={option.value} value={option.value}>{option.text}</option>;
          })
          }
        </select>
        {error && <div className="alert alert-danger">{error}</div>}
      </div>
    </div>
  );
};

SelectInput.propTypes = {
  name: PropTypes.string.isRequired,
  label: PropTypes.string.isRequired,
  onChange: PropTypes.func.isRequired,
  defaultOption: PropTypes.string,
  value: PropTypes.string,
  error: PropTypes.string,
  options: PropTypes.arrayOf(PropTypes.object)
};

export default SelectInput;


src/actions/authorActions.js
----
import AuthorApi from '../api/mockAuthorApi';
import * as types from './actionTypes';

export function loadAuthorsSuccess(authors) {
  return {type: types.LOAD_AUTHORS_SUCCESS, authors};
}

export function loadAuthors() {
  return dispatch => {
    return AuthorApi.getAllAuthors().then(authors => {
      dispatch(loadAuthorsSuccess(authors));
    }).catch(error => {
      throw(error);
    });
  };
}


src/actions/actionTypes.js
----
export const LOAD_COURSES_SUCCESS = 'LOAD_COURSES_SUCCESS';
export const LOAD_AUTHORS_SUCCESS = 'LOAD_AUTHORS_SUCCESS';
export const CREATE_COURSE_SUCCESS = 'CREATE_COURSE_SUCCESS';
export const UPDATE_COURSE_SUCCESS = 'UPDATE_COURSE_SUCCESS';


src/reducers/authorReducer.js
----
import * as types from '../actions/actionTypes';
import initialState from './initialState';

export default function authorReducer(state = initialState.authors, action) {
  switch (action.type) {
    case types.LOAD_AUTHORS_SUCCESS:
      return action.authors;

    default:
      return state;
  }
}


src/reducers/initialState.js
----
// These are the properties used by Reducers as a default initial state.
// It is a mental map of how the Store data is sliced for reducers.
export default {
  authors: [],
  courses: []
};


src/reducers/courseReducer.js
----
import * as types from '../actions/actionTypes';
import initialState from './initialState';

export default function courseReducer(state = initialState.courses, action) { // this slice of 'state' will be an array of courses
  switch (action.type) {
    case types.LOAD_COURSES_SUCCESS:
      return action.courses;
    case types.CREATE_COURSE_SUCCESS:
      // Since State is immutable, we can't simply change the appropriate index in the array, but we need to re-create the array instead.
      // To achieve this we pick all the 'state' array elements via spread operator (...), add a new element to the end and return a new array.
      return [
        ...state,
        Object.assign({}, action.course)
      ];
    case types.UPDATE_COURSE_SUCCESS:
      // In addition, here we first filter out the course that is updated and then add the new version of it to the end of the new array.
      return [
        ...state.filter(course => course.id !== action.course.id),
        Object.assign({}, action.course)
      ];
    default:
      return state;
  }
}


src/reducers/index.js
----
import {combineReducers} from 'redux';
import courses from './courseReducer';
import authors from './authorReducer';

const rootReducer = combineReducers({
  courses, // in ES5 this would look like courses: courses; by this name this reducer will be reachable, i.e. this.state.courses
  authors
});

export default rootReducer;


src/index.js
----
import 'babel-polyfill';
import React from 'react';
import { render } from 'react-dom';
import configureStore from './store/configureStore';
import {Provider} from 'react-redux';
import { Router, browserHistory } from 'react-router';
import routes from './routes';
import {loadCourses} from './actions/courseActions';
import {loadAuthors} from './actions/authorActions';
import './styles/styles.css'; //Webpack can import CSS files too!
import '../node_modules/bootstrap/dist/css/bootstrap.min.css';

// If we wanted to rehydrate our store with some initial state passed down from the server, we could supply it to the configureStore()
const store = configureStore();
// Once the Store is configured, we can dispatch Actions against the Store
store.dispatch(loadCourses());
store.dispatch(loadAuthors());

render(
  <Provider store={store}>
    <Router history={browserHistory} routes={routes} />
  </Provider>,
  document.getElementById('app')
);


src/actions/courseActions.js
----
import * as types from './actionTypes';
import courseApi from '../api/mockCourseApi';

export function loadCoursesSuccess(courses) {
  return { type: types.LOAD_COURSES_SUCCESS, courses }; // in ES5 the Object declaration would look like { type: types.LOAD_COURSES_SUCCESS, courses: courses }
}

export function createCourseSuccess(course) {
  return {type: types.CREATE_COURSE_SUCCESS, course};
}

export function updateCourseSuccess(course) {
  return {type: types.UPDATE_COURSE_SUCCESS, course};
}

// We're making an async call to an API, so we'll want to handle the promise returned by getAllCourses() and then dispatch an action when the promise is resolved.
export function loadCourses() { // this is our Thunk
    return function(dispatch) { // this wrapper funciton will exist in every one of our Thunks
      return courseApi.getAllCourses().then(courses => { // getAllCourses() returns a promise
        dispatch(loadCoursesSuccess(courses));
      }).catch(error => {
        throw(error);
      });
    };
}

export function saveCourse(course) {
  return function (dispatch, getState) { // The 'getState' is an optional parameter, which is useful when we need to access the Redux store to get the particular
                                         // pieces of state without the need of passing them in as parameters. We don't need it here, since we already have the
                                         // 'course' passed in (for getting the course.id), but this will become useful when the application grows bigger.
    return courseApi.saveCourse(course).then(savedCourse => {
      course.id ? dispatch(updateCourseSuccess(savedCourse)) : dispatch(createCourseSuccess(savedCourse));
    }).catch(error => {
      throw(error);
    });
  };
}


src/components/course/CoursesPage.js
----
import React, { PropTypes } from 'react';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import * as courseActions from '../../actions/courseActions';
import CourseList from './CourseList';
import {browserHistory} from 'react-router';

class CoursesPage extends React.Component {

  constructor(props, context) {
    super(props, context);
    this.redirectToAddCoursePage = this.redirectToAddCoursePage.bind(this);
  }

  courseRow(course, index) {
    return <div key={index}>{course.title}</div>;
  }

  redirectToAddCoursePage() {
    browserHistory.push("/course");
  }

  render() {
    const { courses } = this.props; // in ES5 this would look like as: var courses = this.props.courses;
    return (
      <div>
        <h1>Courses</h1>
        <input type="submit"
          value="Add Course"
          className="btn btn-primary"
          onClick={this.redirectToAddCoursePage} />
        <CourseList courses={courses} /> {/* could pass {this.props.courses} also */}
      </div>
    );
  }
}

CoursesPage.propTypes = {
  courses: PropTypes.array.isRequired,
  actions: PropTypes.object.isRequired
};

function mapStateToProps(state, ownProps) {
  return {
    courses: state.courses // the name 'courses' of state depends on how the courseReducer is referenced to in rootReducer, i.e. src/reducers/index.js
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: bindActionCreators(courseActions, dispatch)
  };
}

// connect(mapStateToProps, mapDispatchToProps) returns a function, which is invoked with CoursesPage argument
export default connect(mapStateToProps, mapDispatchToProps)(CoursesPage);



11. Async Status and Error Handling
===================

* General concepts:
  - Loading Dots - controlled by a 'ajaxCallsInProgress' state property from Redux Store
    ~ Listener: App.js -> Header.js
    ~ Issuer: courseAction.js (before API call and in case of error) -> ajaxStatusReducer.js
  - Enabled/disabled Save button - controlled by 'saving' property of the local state in ManageCoursePage.js that is passed down to CourseForm.js
    ~ Set to false: constructor, saveCourse(event) on failure, redirect()
    ~ Set to true: saveCourse(event) at the start
  - Popping (toastr) messages - ManageCoursePage.js
    ~ Success: redirect()
    ~ Failure: saveCourse(event) on failure
  - Error handling: Catching promise rejections from
    ~ courseActions.js - throwing error on API call promise reject(error)
    ~ ManageCoursePage.js - catching promise error thrown by courseActions.js, seting 'saving' to false, pushing toastr.error(message)


src/components/common/LoadingDots.js
----
import React, {PropTypes} from 'react';

class LoadingDots extends React.Component {
  constructor(props, context) {
    super(props, context);

    this.state = {frame: 1};
  }

  componentDidMount() {
    this.interval = setInterval(() => {
      this.setState({  // eslint-disable-line react/no-did-mount-set-state
        frame: this.state.frame + 1
      });
    }, this.props.interval);
  }

  componentWillUnmount() {
    clearInterval(this.interval);
  }

  render() {
    let dots = this.state.frame % (this.props.dots + 1);
    let text = '';
    while (dots > 0) {
      text += '.';
      dots--;
    }
    return <span {...this.props}>{text}&nbsp;</span>;
  }
}

LoadingDots.defaultProps = {
  interval: 300, dots: 3
};

LoadingDots.propTypes = {
  interval: PropTypes.number,
  dots: PropTypes.number
};

export default LoadingDots;


src/components/common/Header.js
----
import React, { PropTypes } from 'react';
import { Link, IndexLink } from 'react-router';
import LoadingDots from './LoadingDots';

const Header = ({ loading }) => {
  return (
    <nav>
      {/* The class value of activeClassName styles the currently selected anchor accordingly. */}
      <IndexLink to="/" activeClassName="active">Home</IndexLink>
      {" | "}
      <Link to="/courses" activeClassName="active">Courses</Link>
      {" | "}
      <Link to="/about" activeClassName="active">About</Link>
      {/* The trick with below is that the right-hand side of the expression is only evaluated if the left-hand side is true. */}
      {loading && <LoadingDots interval={100} dots={20} />}
    </nav>
  );
};

Header.propTypes = {
  loading: PropTypes.bool.isRequired
};

export default Header;


src/actions/ajaxStatusActions.js
----
import * as types from './actionTypes';

export function beginAjaxCall() {
  return {type: types.BEGIN_AJAX_CALL};
}

export function ajaxCallError() {
  return {type: types.AJAX_CALL_ERROR};
}


src/actions/actionTypes.js
----
export const BEGIN_AJAX_CALL = 'BEGIN_AJAX_CALL';
export const AJAX_CALL_ERROR = 'AJAX_CALL_ERROR';

export const LOAD_COURSES_SUCCESS = 'LOAD_COURSES_SUCCESS';
export const LOAD_AUTHORS_SUCCESS = 'LOAD_AUTHORS_SUCCESS';
export const CREATE_COURSE_SUCCESS = 'CREATE_COURSE_SUCCESS';
export const UPDATE_COURSE_SUCCESS = 'UPDATE_COURSE_SUCCESS';


src/reducers/initialState.js
----
// These are the properties used by Reducers as a default initial state.
// It is a mental map of how the Store data is sliced for reducers.
export default {
  authors: [],
  courses: [],
  ajaxCallsInProgress: 0
};


src/reducers/ajaxStatusReducer.js
----
import * as types from '../actions/actionTypes';
import initialState from './initialState';

function actionTypeEndsInSuccess(type) {
  return type.substring(type.length - 8) == '_SUCCESS';
}

  // Since all Reducers are invoked for all Actions - capturing each invocation here also and amending ajaxCallsInProgress property of the State
  // based on how the API call ended.
export default function ajaxStatusReducer(state = initialState.ajaxCallsInProgress, action) {
  if (action.type == types.BEGIN_AJAX_CALL) {
    return state + 1;
  } else if (actionTypeEndsInSuccess(action.type) || action.type == types.AJAX_CALL_ERROR) {
    return state - 1;
  }

  return state;
}


src/reducers/index.js
----
import {combineReducers} from 'redux';
import courses from './courseReducer';
import authors from './authorReducer';
import ajaxCallsInProgress from './ajaxStatusReducer';

const rootReducer = combineReducers({
  courses, // in ES5 this would look like courses: courses; by this name this reducer will be reachable, i.e. this.state.courses
  authors,
  ajaxCallsInProgress
});

export default rootReducer;


src/actions/courseActions.js
----
import * as types from './actionTypes';
import courseApi from '../api/mockCourseApi';
import {beginAjaxCall, ajaxCallError} from './ajaxStatusActions';

export function loadCoursesSuccess(courses) {
  return { type: types.LOAD_COURSES_SUCCESS, courses }; // in ES5 the Object declaration would look like { type: types.LOAD_COURSES_SUCCESS, courses: courses }
}

export function createCourseSuccess(course) {
  return {type: types.CREATE_COURSE_SUCCESS, course};
}

export function updateCourseSuccess(course) {
  return {type: types.UPDATE_COURSE_SUCCESS, course};
}

// We're making an async call to an API, so we'll want to handle the promise returned by getAllCourses() and then dispatch an action when the promise is resolved.
// Note that in the thunk we are dispatching 2 actions that will be handled by 2 separate reducers - ajaxStatusReducer.js and courseReducer.js
export function loadCourses() { // this is our Thunk
    return function(dispatch) { // this wrapper funciton will exist in every one of our Thunks
      dispatch(beginAjaxCall()); // alternatively, dispatching of this action could be moved to real API handling file
      return courseApi.getAllCourses().then(courses => { // getAllCourses() returns a promise
        dispatch(loadCoursesSuccess(courses));
      }).catch(error => {
        throw(error);
      });
    };
}

export function saveCourse(course) {
  return function (dispatch, getState) { // The 'getState' is an optional parameter, which is useful when we need to access the Redux store to get the particular
                                         // pieces of state without the need of passing them in as parameters. We don't need it here, since we already have the
                                         // 'course' passed in (for getting the course.id), but this will become useful when the application grows bigger.
    dispatch(beginAjaxCall());
    return courseApi.saveCourse(course).then(savedCourse => {
      course.id ? dispatch(updateCourseSuccess(savedCourse)) : dispatch(createCourseSuccess(savedCourse));
    }).catch(error => {
      dispatch(ajaxCallError(error)); // prevents loading dots
      throw(error);
    });
  };
}


src/actions/authorActions.js
----
import AuthorApi from '../api/mockAuthorApi';
import * as types from './actionTypes';
import {beginAjaxCall} from './ajaxStatusActions';

export function loadAuthorsSuccess(authors) {
  return {type: types.LOAD_AUTHORS_SUCCESS, authors};
}

export function loadAuthors() {
  return dispatch => {
    dispatch(beginAjaxCall());
    return AuthorApi.getAllAuthors().then(authors => {
      dispatch(loadAuthorsSuccess(authors));
    }).catch(error => {
      throw(error);
    });
  };
}


src/components/App.js
----
// This component handles the App template used on every page.
import React, {PropTypes} from 'react';
import Header from './common/Header';
import {connect} from 'react-redux';

class App extends React.Component {
  render() {
    return (
      <div className="container-fluid">
        <Header
          loading={this.props.loading}
        />
        {/* These "children" (e.g. AboutPage, HomePage, etc.) will be passed over from the react-router
            to App component (in routes.js) and then they will be composed right here on the page. */}
        {this.props.children}
      </div>
    );
  }
}

App.propTypes = {
  children: PropTypes.object.isRequired,
  loading: PropTypes.bool.isRequired
};

function mapStateToProps(state, ownProps) {
  return {
    // 'ajaxCallsInProgress' is the property of state, but the derived value of 'loading' is passed down via props to this component onwards
    loading: state.ajaxCallsInProgress > 0
  };
}

export default connect(mapStateToProps)(App);


src/components/course/ManageCoursePage.js
----
import React, { PropTypes } from 'react';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import * as courseActions from '../../actions/courseActions';
import CourseForm from './CourseForm';
import toastr from 'toastr';

export class ManageCoursePage extends React.Component {
  constructor(props, context) {
    super(props, context);

    // Setting initial LOCAL (not Redux) state
    // Constructor specific: 'this' reference can be omitted; can change state directly, i.e. without calling this.setState()
    this.state = {
      course: Object.assign({}, this.props.course), // this.props.course are coming in from the component higher in hierarchy
      errors: {},
      saving: false // controls the Save button name and disabled status
    };

    // Need to change 'this' context of change handlers, as otherwise the 'this' context
    // of an input element is picked, where this.state doesn't exist.
    this.updateCourseState = this.updateCourseState.bind(this);
    this.saveCourse = this.saveCourse.bind(this);
  }

  // This lifecycle function is invoked each time the props are updated.
  // This way the course data still gets populated after the page refresh.
  componentWillReceiveProps(nextProps) {
    if (this.props.course.id != nextProps.course.id) { // sometimes React doesn't know for sure whether props have changed, so it runs this method for safety
      // Necessary to populate form when existing course is loaded directly.
      this.setState({ course: Object.assign({}, nextProps.course) });
    }
  }

  // A single change handler for all our form fields
  updateCourseState(event) {
    const field = event.target.name;
    let course = Object.assign({}, this.state.course); // avoiding mutating the state
    course[field] = event.target.value;
    return this.setState({ course: course });
  }

  saveCourse(event) {
    event.preventDefault();
    this.setState({ saving: true });
    // In order to not redirect immediately, we use 'then' method to wait for the promise to complete first.
    this.props.actions.saveCourse(this.state.course)
      .then(() => this.redirect())
      .catch(error => {
        this.setState({ saving: false });
        toastr.error(error);
      });
  }

  redirect() {
    this.setState({ saving: false });
    toastr.success('Course saved');
    // the this.context.router was pulled in by declaring static object ManageCoursePage.contextTypes
    this.context.router.push('/courses'); // an alternative to browserHistory.push("/courses");
  }

  render() {
    return (
      // Here 'authors' object is returned as a property via mapStateToProps().
      // this.state.course and this.state.errors are both part of the LOCAL component state and have nothing to do with Redux.
      <CourseForm
        allAuthors={this.props.authors}
        onChange={this.updateCourseState}
        onSave={this.saveCourse}
        course={this.state.course}
        errors={this.state.errors}
        saving={this.state.saving}
      />
    );
  }
}

ManageCoursePage.propTypes = {
  course: PropTypes.object.isRequired,
  authors: PropTypes.array.isRequired,
  actions: PropTypes.object.isRequired
};

// Pull in the React Router context so router is available on this.context.router (used in saveCourse())
// 'context' is a global variable that library authors use, but we as library consumers should avoid.
ManageCoursePage.contextTypes = {
  router: PropTypes.object
};

function getCourseById(courses, id) {
  const course = courses.filter(course => course.id == id);
  if (course.length) {
    return course[0]; // since filter returns an array, have to grab the first element
  } else {
    return null;
  }
}

function mapStateToProps(state, ownProps) { // 'ownProps' is a reference to our component's props

  // The Redux state is passed as an argument to this funciton and we can access it.

  const courseId = ownProps.params.id; // from the route path `/course/:id` at routes.js that the component itself has the access to (it is not in Redux)

  let course = { id: '', watchRef: '', title: '', authorId: '', length: '', category: '' };
  if (courseId && state.courses.length > 0) {
    course = getCourseById(state.courses, courseId);
  }

  // We have the this.state.authors set here (populated in index.js), but the shape isn't the one we need.
  // The SelectInput component accepts the data in value:text format, so we're formatting it here.
  const authorsFormattedForDropdown = state.authors.map(author => {
    return {
      value: author.id,
      text: author.firstName + ' ' + author.lastName
    };
  });

  // Here we are shaping the Redux store data to be available via props to this component.
  return {
    course: course,
    authors: authorsFormattedForDropdown // the Redux Store still contains the unformatted author list,
    // but the formatted one is passed down via props over to this component
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: bindActionCreators(courseActions, dispatch)
  };
}

export default connect(mapStateToProps, mapDispatchToProps)(ManageCoursePage);


src/index.js
----
import 'babel-polyfill';
import React from 'react';
import { render } from 'react-dom';
import configureStore from './store/configureStore';
import {Provider} from 'react-redux';
import { Router, browserHistory } from 'react-router';
import routes from './routes';
import {loadCourses} from './actions/courseActions';
import {loadAuthors} from './actions/authorActions';
import './styles/styles.css'; //Webpack can import CSS files too!
import '../node_modules/bootstrap/dist/css/bootstrap.min.css';
import '../node_modules/toastr/build/toastr.min.css';

// If we wanted to rehydrate our store with some initial state passed down from the server, we could supply it to the configureStore()
const store = configureStore();
// Once the Store is configured, we can dispatch Actions against the Store
store.dispatch(loadCourses());
store.dispatch(loadAuthors());

render(
  <Provider store={store}>
    <Router history={browserHistory} routes={routes} />
  </Provider>,
  document.getElementById('app')
);



12. Testing React
===================





Appendix: ES6
===================

* Constructor
  - state can be set directly, i.e. without calling this.setState();
  - 'this' keyword can be omitted?

* 'var' is to be avoided, but 'let' and 'const' are to be used.
  'const' is more strict and doesn't allow the variable to be reassigned a different value.

* The arrow function syntax '(...) => { ... }' is used insted of traditional 'function(...) { ... }' syntax and it is a matter of taste.
  The () can be omitted if there is only 1 parameter.

* A new approach to clone an object in JavaScript is to use Object.assign().
  This method creates a new object, but allows to specify existing objects as a template.
  Signature: Object.assign(target, ...sources)
  Example:   Object.assign({}, state, {role: 'admin'});
  A new object is created '{}', then it is mixed with the 'state' object and then with the anonymous object, which changes the 'role' property.
  It is important for the 1st parameter to be an empty object, as otherwise the 'state' would be mutated.
  Not all browsers yet support Object.assign() and Babel doesn't transpile it, so 'babel-polyfill' must be included at the root of the app (index.js).

* Shorthand property names
  const action = { type: 'CREATE_COURSE', course }; // in ES5 the Object declaration would look like { type: 'CREATE_COURSE', course: course }

* Spread operator (...)
  const course = {title: 'JS Dev Env', author: 'Cory House', length: '5 hrs'};
  ...course

* Generators - functions that can be paused and resumed later. A Generator can contain multiple yield statements. At each yield, the generator will pause.

* Promises -
