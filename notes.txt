1. Intro
===================
* ES6 with Babel and Webpack has become a de-facto way to build the React applications.
* Redux created at 2015 had become a de facto Flux implementation.
* Why Redux?
  - One Store
  - Reduced Boilerplate
  - Isomorphic/Universal Friendly
  - Immutable Store
  - Hot Reloading
  - Time-travel debugging
  - Small



2. Environment Setup
===================
* Resources:
  - The official react starter kit by Cory House, called React Slingshot: https://github.com/coryhouse/react-slingshot
  - The environment setup resources for this course, a simplified version: https://github.com/coryhouse/pluralsight-redux-starter
* Target - do all of the following in one command:
  - Automated Testing (Mocha)
  - Linting (ESLint)
  - Minification (webpack)
  - Bundling (webpack)
  - JSX compilation (reactify)
  - ES6 transpilation (Babel)
  - Serving the app (Express)
  - Tying all together (npm scripts)
* Transpiling:
  - Having Babel transpiling ES6 to ES5, the Polyfills are used when some ES6 features can't be simply transpiled, e.g. array.from, set, map, promise, generators, etc.
    Babel-polyfill can polyfill all these features so that ES6 can be safely used. It is used in this course for simplicity, however, it weights a lot and the better
    alternative is to go after the individual polyfills required by the application and most of those are available as an individual npm packages.
* Hot Reloading:
  - There are multiple ways to handle hot reloading, which is likely change in the future, and this course will use babel-preset-react-hmre.
    The babel-preset-react-hmre wraps a number of other libraries and settings in a single preset that's easy to set up.
    It works by wrapping your components in a custom proxy using Babel. The proxies are classes that act just like your classes,
    but they provide hooks for injecting new implementations, so that when you hit save, your changes are applied without requiring a reload.
    Bottom line is that we are going to install babel-preset-react-hmre npm package and put a reference to it in .babelrc.
  - Warning:
    ~ Hot reloading is still experimental. There are likely to be better ways to handle this in the future.
    ~ Doesn't hot reload Functional components, unless there is a Class somewhere up hierarchy tree (there usually is).
    ~ Doesn't hot reload Container functions, like mapStateToProps.
    ~ Other options exist - React Hot Loader 3.0 is in alpha currently and it addresses those downsides. This will be the recommended approach.
* Versions:
  - Node 6.10 (can run multiple versions of node via nvm-windows)
  - React 15.0.2
  - Redux 3.5.2
  - React-router 2.4.0
  - Webpack 1.13
  - Babel 6.*
* Editors:
  - Webstorm - best ES6 support, powerful refactoring tools, autocompletion, etc.
  - Atom with 'react' (language support, indentation, snippets, auto completion, reformatting) and 'terminal-plus' (integrated terminal) packages
* Build:
  - npm scripts instead of Grunt or Gulp - bit.ly/npmvsgulp
* webpack.config.dev.js configuration options:
  - debug - enables displaying the debug informaiton.
  - devtool - a way to map the minified code sent to browser to the source code that is also sent along, so that the front-end debugging is comfortable.
  - noInfo - enables displaying the list of files the webpack is bundling.
  - entry - an array of entry points for development, which is a good way to inject middleware for things like hot reloading.
            The order is critical and an entry point for our app comes last.
  - target - the target execution environment type, which is used by bundler in order to bundle the code correctly.
  - output - specifies where the webpack whould create our dev bundle. Webpack isn't actually going to generate any physical files, but will create bundles in memory.
             We need this option to simulate the physical file's existence and have something to refer to in index.html for example.
             The real physical files will be created during the production build though.
  - devServer - mainly it specifies where are the source files that are to be bundled and served.
  - plugins - enabling additional webpack capabilities.
  - module - tells webpack what kind of file types it should handle. We could handle SaaS and LESS here also.
* .eslintrc configuration options:
  - extends - usually is extending eslint recommended settings as a baseline and augmenting them with plugins for enhanced linting for ES6 imports.
  - plugins - here we will use the React plugin to add a number of useful React-specific linting rules (prefixed with 'react/').
  - rules - linting rule preferences. 0 - off, 1 - warning, 2 - error (breaks the build).
  - parserOptions - enables ES6 and JSX.
  - env - declares the environments eslint should be aware of, i.e. to expect certain global variables.
* npm commands
  >npm install
  >npm start -s


.editorconfig
----
# editorconfig.org
root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.md]
trim_trailing_whitespace = false


.eslintrc
----
{
  "extends": [
    "eslint:recommended",
    "plugin:import/errors",
    "plugin:import/warnings"
  ],
  "plugins": [
    "react"
  ],
  "parserOptions": {
    "ecmaVersion": 6,
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "env": {
    "es6": true,
    "browser": true,
    "node": true,
    "jquery": true,
    "mocha": true
  },
  "rules": {
    "quotes": 0,
    "no-console": 1,
    "no-debugger": 1,
    "no-var": 1,
    "semi": [1, "always"],
    "no-trailing-spaces": 0,
    "eol-last": 0,
    "no-unused-vars": 0,
    "no-underscore-dangle": 0,
    "no-alert": 0,
    "no-lone-blocks": 0,
    "jsx-quotes": 1,
    "react/display-name": [ 1, {"ignoreTranspilerName": false }],
    "react/forbid-prop-types": [1, {"forbid": ["any"]}],
    "react/jsx-boolean-value": 1,
    "react/jsx-closing-bracket-location": 0,
    "react/jsx-curly-spacing": 1,
    "react/jsx-indent-props": 0,
    "react/jsx-key": 1,
    "react/jsx-max-props-per-line": 0,
    "react/jsx-no-bind": 1,
    "react/jsx-no-duplicate-props": 1,
    "react/jsx-no-literals": 0,
    "react/jsx-no-undef": 1,
    "react/jsx-pascal-case": 1,
    "react/jsx-sort-prop-types": 0,
    "react/jsx-sort-props": 0,
    "react/jsx-uses-react": 1,
    "react/jsx-uses-vars": 1,
    "react/no-danger": 1,
    "react/no-did-mount-set-state": 1,
    "react/no-did-update-set-state": 1,
    "react/no-direct-mutation-state": 1,
    "react/no-multi-comp": 1,
    "react/no-set-state": 0,
    "react/no-unknown-property": 1,
    "react/prefer-es6-class": 1,
    "react/prop-types": 1,
    "react/react-in-jsx-scope": 1,
    "react/require-extension": 1,
    "react/self-closing-comp": 1,
    "react/sort-comp": 1,
    "react/wrap-multilines": 1
  }
}


package.json
----
{
  "name": "react-redux-building-applications",
  "version": "1.0.0",
  "description": "Starter kit for React and Redux Pluralsight course by Cory House",
  "scripts": {
    "prestart": "babel-node tools/startMessage.js",
    "start": "npm-run-all --parallel test:watch open:src lint:watch",
    "open:src": "babel-node tools/srcServer.js",
    "lint": "node_modules/.bin/esw webpack.config.* src tools",
    "lint:watch": "npm run lint -- --watch",
    "test": "mocha --reporter progress tools/testSetup.js \"src/**/*.test.js\"",
    "test:watch": "npm run test -- --watch"
  },
  "author": "Aleksandr Fokin",
  "license": "MIT",
  "dependencies": {
    "babel-polyfill": "6.8.0",
    "bootstrap": "3.3.6",
    "jquery": "2.2.3",
    "react": "15.0.2",
    "react-dom": "15.0.2",
    "react-redux": "4.4.5",
    "react-router": "2.4.0",
    "react-router-redux": "4.0.4",
    "redux": "3.5.2",
    "redux-thunk": "2.0.1",
    "toastr": "2.1.2"
  },
  "devDependencies": {
    "babel-cli": "6.8.0",
    "babel-core": "6.8.0",
    "babel-loader": "6.2.4",
    "babel-plugin-react-display-name": "2.0.0",
    "babel-preset-es2015": "6.6.0",
    "babel-preset-react": "6.5.0",
    "babel-preset-react-hmre": "1.1.1",
    "babel-register": "6.8.0",
    "cheerio": "0.22.0",
    "colors": "1.1.2",
    "compression": "1.6.1",
    "cross-env": "1.0.7",
    "css-loader": "0.23.1",
    "enzyme": "2.2.0",
    "eslint": "2.9.0",
    "eslint-plugin-import": "1.6.1",
    "eslint-plugin-react": "5.0.1",
    "eslint-watch": "2.1.11",
    "eventsource-polyfill": "0.9.6",
    "expect": "1.19.0",
    "express": "4.13.4",
    "extract-text-webpack-plugin": "1.0.1",
    "file-loader": "0.8.5",
    "jsdom": "8.5.0",
    "mocha": "2.4.5",
    "nock": "8.0.0",
    "npm-run-all": "1.8.0",
    "open": "0.0.5",
    "react-addons-test-utils": "15.0.2",
    "redux-immutable-state-invariant": "1.2.3",
    "redux-mock-store": "1.0.2",
    "rimraf": "2.5.2",
    "style-loader": "0.13.1",
    "url-loader": "0.5.7",
    "webpack": "1.13.0",
    "webpack-dev-middleware": "1.6.1",
    "webpack-hot-middleware": "2.10.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/RockingChewee/react-redux-building-applications"
  }
}


webpack.config.dev.js
----
import webpack from 'webpack';
import path from 'path';

export default {
  debug: true,
  devtool: 'inline-source-map',
  noInfo: false,
  entry: [
    'eventsource-polyfill', // necessary for hot reloading with IE
    'webpack-hot-middleware/client?reload=true', //note that it reloads the page if hot module reloading fails.
    path.resolve(__dirname, 'src/index') // our application's actual entry point, has to be last
  ],
  target: 'web',
  output: {
    path: __dirname + '/dist', // Note: Physical files are only output by the production build task `npm run build`.
    publicPath: '/',
    filename: 'bundle.js'
  },
  devServer: {
    contentBase: path.resolve(__dirname, 'src')
  },
  plugins: [
    new webpack.HotModuleReplacementPlugin(), // enables to hot-replace modules without a full browser refresh
    new webpack.NoErrorsPlugin() // keeps errors from breaking our hot reloading experience
  ],
  module: {
    loaders: [
      {test: /\.js$/, include: path.join(__dirname, 'src'), loaders: ['babel']},
      {test: /(\.css)$/, loaders: ['style', 'css']}, // we could tell webpack to handle SaaS and LESS files here also
      {test: /\.eot(\?v=\d+\.\d+\.\d+)?$/, loader: 'file'}, // the following 4 instructions are necessary for the file types Bootstrap utilizes for fonts
      {test: /\.(woff|woff2)$/, loader: 'url?prefix=font/&limit=5000'},
      {test: /\.ttf(\?v=\d+\.\d+\.\d+)?$/, loader: 'url?limit=10000&mimetype=application/octet-stream'},
      {test: /\.svg(\?v=\d+\.\d+\.\d+)?$/, loader: 'url?limit=10000&mimetype=image/svg+xml'}
    ]
  }
};


.babelrc - all the mentioned presents were installed as npm modules (es2015, react, react-hmre)
----
{
  "presets": ["react", "es2015"],
  "env": {
    "development": {
      "presets": ["react-hmre"]
    }
  }
}


tools/srcServer.js
----
import express from 'express';
import webpack from 'webpack';
import path from 'path';
import config from '../webpack.config.dev';
import open from 'open';

/* eslint-disable no-console */

const port = 3000;
const app = express(); // creating instance of express
const compiler = webpack(config); // getting a compiled webpack config

app.use(require('webpack-dev-middleware')(compiler, {
  noInfo: true,
  publicPath: config.output.publicPath
}));

app.use(require('webpack-hot-middleware')(compiler));

app.get('*', function(req, res) { // since this is a one page app, we are serving index.html for all requests
  res.sendFile(path.join( __dirname, '../src/index.html'));
});

app.listen(port, function(err) {
  if (err) {
    console.log(err);
  } else {
    open(`http://localhost:${port}`);
  }
});


tools/startMessage.js
----
import colors from 'colors';

/* eslint-disable no-console */

console.log('Starting app in dev mode...'.green);


tools/testSetup.js
----
// This file is written in ES5 since it's not transpiled by Babel.
// This file does the following:
// 1. Sets Node environment variable
// 2. Registers babel for transpiling our code for testing
// 3. Disables Webpack-specific features that Mocha doesn't understand.
// 4. Requires jsdom so we can test via an in-memory DOM in Node
// 5. Sets up global vars that mimic a browser.

/* eslint-disable no-var*/

/* This setting assures the .babelrc dev config (which includes
 hot module reloading code) doesn't apply for tests.
 But also, we don't want to set it to production here for
 two reasons:
 1. You won't see any PropType validation warnings when
 code is running in prod mode.
 2. Tests will not display detailed error messages
 when running against production version code
 */
process.env.NODE_ENV = 'test';

// Register babel so that it will transpile ES6 to ES5
// before our tests run.
require('babel-register')();

// Disable webpack-specific features for tests since
// Mocha doesn't know what to do with them.
require.extensions['.css'] = function () {return null;};
require.extensions['.png'] = function () {return null;};
require.extensions['.jpg'] = function () {return null;};

// Configure JSDOM and set global variables
// to simulate a browser environment for tests.
var jsdom = require('jsdom').jsdom;

var exposedProperties = ['window', 'navigator', 'document'];

global.document = jsdom('');
global.window = document.defaultView;
Object.keys(document.defaultView).forEach((property) => {
  if (typeof global[property] === 'undefined') {
    exposedProperties.push(property);
    global[property] = document.defaultView[property];
  }
});

global.navigator = {
  userAgent: 'node.js'
};

documentRef = document;  //eslint-disable-line no-undef


src/index.html
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Pluralsight Admin</title>
  </head>
  <body>
    <h1>React and Redux in ES6 on Pluralsight</h1>
    <div id="app"></div>
    <script src="/bundle.js"></script>
  </body>
</html>


src/index.js
----
/* eslint-disable no-console */
console.log('hi');


src/index.test.js
----
import expect from 'expect';

describe('Our first test', () => {
  it('should pass', () => {
    expect(true).toEqual(true);
  });
});



3. React Component Approaches
===================

* React component creation Approaches
  - ES5 createClass
    var HelloWorld = React.createClass({
      render: function() {
        return (
          <h1>Hello World</h1>
        );
      }
    });
  - ES6 class
    class Contacts extends React.Component {
      render() {
        return (
          <h1>Hello World</h1>
        );
      }
    }
  - ES5 stateless function
    var HelloWorld = function(props) {
      return (
        <h1>Hello World</h1>
      );
    };
  - ES6 stateless function
    const HelloWorld = (props) => {
      return (
        <h1>Hello World</h1>
      );
    };
  - Many more... - http://bit.ly/react-define-component
    ~ Object.create
    ~ Mixins
    ~ Parasitic Components
    ~ StampIt

* Differences when creating React components in ES5 and ES6:

  - React components built with ES6 classes do NOT autobind automatically:

    // Works fine with ES5 createClass
    <div onClick={this.handleClick}></div>

    // Requires explicit bind with ES6 Class
    <div onClick={this.handleClick.bind(this)}></div>

    // OR for performance reasons, binding can be done in the constructor
    class Contacts extends React.Component {
      constructor(props) {
        super(props);
        this.handleClick = this.handleClick.bind(this);
      }
    }

  - PropTypes and Default props are declared separately, below the class definition.

  - setInitialState() isn't utilized in ES6 classes, but the initial state is set in constructor instead.

* Benefits of stateless functional components - use whenever possible:
  - No class needed
  - Avoid 'this' keyword
  - Enforced best practices - no state is handled in these components, therefore they remain pure and do not allow introducing of quick hacks.
  - High signal-to-noise ration - less code
  - Enhanced code completion / intellisense - if to destructure props in ES6 (example), then all needed data is held within a single function argument.
  - Bloated components are obvious - the function that takes a lot of parameters is a code smell.
  - Easier to understand - the components like that is a simple funciton that takes props and spits out HTML.
  - Easier to test, since we know it is just a markup.
  - Better performance - no state or lifecycle methods to worry about.

* When to use React class components over stateless functional components:
  - Use React class components when:
    ~ State - there is a need to utilize and maintain local state.
    ~ Refs - when it is needed to get a reference to the underlying DOM, since the stateless components don't actually create the component instance.
    ~ Lifecycle methods - when those hooks are needed.
    ~ Child functions - in stateless functional components each render creates a new instance of the nested function, which hurts the performance.
  - Use React stateless functional components:
    ~ Everywhere else.

* Container vs Presentational components:
  - Container components (also known as Smart, Stateful, Controller View):
    ~ have most of the smarts and least of the markup. These components can be thought of as a back-end for the front-end.
    ~ are primarily concerned with passing data and actions down to their children, usually presentation components.
    ~ have a Redux-specific code inside for dispatching actions to the store and connecting to the store via connect.
    ~ are usually stateful.
  - Presentation components (also known as Dumb, Stateless, View):
    ~ are nearly all markup with little to none logic inside.
    ~ receive data and actions they need from a container component via props.
    ~ typically know nothing about Redux.
    ~ are typically stateless.

* Nested Container components:
  A quote from Dan Abramov (creator of Redux)when trying to decide whether to create Container or Presentational component:
  "When you notice that some components don't use props they receive but merely forward them down, it's a good time to introduce some container components."
  This is supposed to be a criteria to create nested Container components, which is normally avoided for performance reasons.


ES6 class example:
----
import React from 'react';
class HelloWorld extends React.Component {
  constructor(props) {
    super(props);
  }
  sayHi(event) {
    alert(`Hi ${this.props.name}`);
  }
  render() {
    return (
      <div>
        <a href="#" onClick={this.sayHi.bind(this)}>Say Hi</a>
      </div>
    );
  }
}
HelloWorld.propTypes = {
  name: React.PropTypes.string.isRequired
};
export default HelloWorld;


ES6 stateless functional component example
----
import React from 'react';
const HelloWorld = (props) => {
  const sayHi = (event) => {
    alert(`Hi ${props.name}`);
  }
  return (
    <div>
      <a href="#" onClick={sayHi}>Say Hi</a>
    </div>
  );
}
HelloWorld.propTypes = {
  name: React.PropTypes.string.isRequired
};
export default HelloWorld;



4. Initial App Structure
===================
* Purpose of this module is to create app foundation:
  - Create first pages
  - Create layout
  - Configure routing
  - Setup navigation

* Hot-reloading:
  - The src/components/about/AboutPage.js could totally be a functional stateless component, however, currently there is a limitation with hot-reloading,
    which doesn't work unless somewhere at the top of the components hierarchy there is a class component.
  - HTML files are also NOT a part of the hot-reloading lifecycle.


src/components/about/AboutPage.js
----
import React from 'react';

class AboutPage extends React.Component {
  render() {
    return (
      <div>
        <h1>About</h1>
        <p>This application uses React, Redux, React Router and a variety of other helpful libraries.</p>
      </div>
    );
  }
}

export default AboutPage;


src/components/home/HomePage.js
----
import React from 'react';
import {Link} from 'react-router';

class HomePage extends React.Component {
  render() {
    return (
      <div className="jumbotron">
        <h1>Pluralsight Administration</h1>
        <p>React, Redux and React Router in ES6 for ultra-responsive web apps.</p>
        <Link to="about" className="btn btn-primary btn-lg">Learn more</Link>
      </div>
    );
  }
}

export default HomePage;


src/components/App.js
----
// This component handles the App template used on every page.
import React, {PropTypes} from 'react';
import Header from './common/Header';

class App extends React.Component {
  render() {
    return (
      <div className="container-fluid">
        <Header/>
        {/* These "children" (e.g. AboutPage, HomePage, etc.) will be passed over from the react-router
            to App component (in routes.js) and then they will be composed right here on the page. */}
        {this.props.children}
      </div>
    );
  }
}

App.propTypes = {
  children: PropTypes.object.isRequired
};

export default App;


src/routes.js
----
import React from 'react';
import { Route, IndexRoute } from 'react-router';
import App from './components/App';
import HomePage from './components/home/HomePage';
import AboutPage from './components/about/AboutPage';
import CoursesPage from './components/course/CoursesPage';

export default (
  /* Always load the App component and then pass the nested items as "children" to the App based on the routing. */
  <Route path="/" component={App}>
    {/* If someone goes to /, we will load the HomePage. */}
    <IndexRoute component={HomePage} />
    <Route path="courses" component={CoursesPage} />
    <Route path="about" component={AboutPage} />
  </Route>
);


src/index.js
----
import 'babel-polyfill';
import React from 'react';
import { render } from 'react-dom';
import { Router, browserHistory } from 'react-router';
import routes from './routes';
import './styles/styles.css'; //Webpack can import CSS files too!
import '../node_modules/bootstrap/dist/css/bootstrap.min.css';

render(
  <Router history={browserHistory} routes={routes} />,
  document.getElementById('app')
);


src/styles/styles.css
----
/* Styles */
#app {
  font: 14px 'Helvetica Neue', Helvetica, Arial, sans-serif;
  color: #4d4d4d;
  min-width: 550px;
  max-width: 850px;
  margin: 0 auto;
}

a.active {
  color: orange;
}

nav {
  padding-top: 20px;
}


src/index.html
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Pluralsight Admin</title>
  </head>
  <body>
    <div id="app"></div>
    <script src="/bundle.js"></script>
  </body>
</html>


src/components/common/Header.js
----
import React, {PropTypes} from 'react';
import { Link, IndexLink } from 'react-router';

const Header = () => {
  return (
    <nav>
      {/* The class value of activeClassName styles the currently selected anchor accordingly. */}
      <IndexLink to="/" activeClassName="active">Home</IndexLink>
      {" | "}
      <Link to="/courses" activeClassName="active">Courses</Link>
      {" | "}
      <Link to="/about" activeClassName="active">About</Link>
    </nav>
  );
};

export default Header;


src/components/course/CoursesPage.js
----
import React, {PropTypes} from 'react';

class CoursesPage extends React.Component {
  render() {
    return (
      <div>
        <h1>Courses</h1>
      </div>
    );
  }
}

export default CoursesPage;



5. Intro to Redux
===================

* Simple setup ------------ Vanilla JS --- jQuery --- React --- React + Redux ----------> Complex setup

* When to use Redux:
  - Complex data flows, i.e. not for static data
  - Inter-component communication, when same data is used in two components that have no parent-child relation
  - Application has non-hierarchical data
  - Application offers an increasing number of actions

* Typical Redux use case:
  Given 2 React components with no parent-child relation, one of the components dispatches an Action to change the data.
  The Centralized Store captures this Action and immediately notifies both components of the data change.

* Redux: 3 core principles:
  - Application state is placed in a single immutable store.
  - The only way to mutate state is to emit an Action, e.g. click on a specific submit button.
  - State is changed by pure functions, called Reducers. Reducer is a function that accepts the current state in an aciton and returns a new state.

* Flux and Redux side by side comparison:
  Flux:                                                          | Redux:
  ---------------------------------------------------------------+----------------------------------------------------------------------------
  Unidirectional data flow - data flows down, actions flow up    | Unidirectional data flow - data flows down, actions flow up
  Actions - describes user intent                                | Actions - describes user intent
  Stores contain state and change logic                          | Store contains state, but the change logic specified in Reducers
  Multiple Stores                                                | Single Store
  Flat and disconnected multiple Stores                          | Single Store with hierarchical (nested) Reducers
  Singleton Dispatcher in a center of an application             | No Dispatcher, where Actions are passed down to the Reducers directly
  React components subscribe to Stores (OnChange & EventEmitter) | Container components utilize connect method of React-Redux library
  State is manipulated directly, i.e. it is mutable              | State is immutable, i.e. a copy of new State is returned from Reducers

* Flux vs Redux flows:
  - Flux flow: ------ React component ----> Action ----> Dispatcher ----> Store ----> React component ------->
    When Actions are triggered, Stores are notified by Dispatcher (singleton). Stores are explicitly connected to Dispatcher via EventEmitter.

  - Redux flow: ----- React component ----> Action ----> Store ----> Reducers ----> Store ----> React component ------->
    ~ Action - an object with a 'type' and some data. {type: RATE_COURSE, rating: 5}
    ~ Reducer - instead of a Dispatcher, Redux relies on pure functions called Reducers, which handle Actions:
      function appReducer(state = defaultState, action) {
        switch (action.type) {
          case RATE_COURSE:
          // return new state
        }
      }
    ~ Store - updated once the new state is returned from a Reducer. Since Stores are immutable in Redux, the Reducers return a new update copy of a
              state, which updates the Store.
    ~ React component - connected to the Store using React-Redux lib.



6. Actions, Store and Reducers
===================
* Actions
  - Action Creator example:
    rateCourse(rating) {
      return { type: RATE_COURSE, rating: 5 };
    }
  - Action Creators are typically named after the Actions they create, e.g. the name of the Action Creator for the RATE_COURSE action is 'rateCourse'.
  - An Action must have 'type' property and the rest of its shape is up to the developer.
  - A 'rating' property could be anything that is serializable to JSON, i.e. a complex object, simple number, boolean, etc.
    The only thing 'rating' couldn't be is a function or a Promise.

* Store
  - In Redux, Store is created by calling createStore in the application's entry point:
    let store = createStore(reducer);
  - Unlike in Flux, in Redux Stores only Store data and the logic to manipulate the data is specifed in Reducers.
  - Having a single Store (single source of truth) makes the application easier to manage and understand.
  - Redux Store API is very simple, i.e. the Store can:
    ~ store.dispatch(action)
    ~ store.subscrbe(listener)
    ~ store.getState()
    ~ replaceReducer(nextReducer) - is useful to support hot-reloading
  - There is no API for changing data in the Store. Only Actions can change state via Reducers.

* Mutability & Immutability
  - Mutability
     ~ JavaScript types: Objects, Arrays, Functions
     ~ Example:
       state = {
         name: 'Cory House',
         role: 'author'
       }
       state.role = 'admin';
       return state;
  - Immutability
    ~ JavaScript types: Number, String, Boolean, Undefined, null
    ~ Example:
      state = {
        name: 'Cory House',
        role: 'author'
      }
      return state = {
        name: 'Cory House',
        role: 'admin'
      };

* Why is state made immutable in Redux:
  - Clarity - when state is updated, it is clear that it was done by a Reducer.
  - Performance - to know if the state has changed, instead of checking the individual properties, it is more efficient to check state like this:
                  if (prevStoreState !== storeState) { ... }
                  This comparison is used to determine when to notify React components of the state changes to trigger shouldComponentUpdate().
  - Amazing Debugging - a powerful way to see how the application state is changing over time:
                        Time-travel debugging, Undo/Redo, Turn off individual Actions, Play interactions back.

* Ways to handling immutability (cloning):
  - ES6: Object.assign, Spread operator
  - ES5: Lodash merge, Lodash extend, Object-assign npm package
  - Libraries: react-addons-update, Immutable.js

* Three different approaches to enforce immutability:
  - Trust your team - hope that everyone remembers to keep state immutable.
  - Install 'redux-immutable-state-invariant' and use it in your Store file - use only in development!!!
  - Use Immutable.js

* Reducers
  - To change the Store, the Action is dispatched that is ultimately handled by a Reducer.
  - Reducers take state and an Action and return a new state:
    function myReducer(state, action) { // OR alternatively in ES6: (state, action) => state
      switch (action.type) {
        case 'INCREMENT_COUNTER':
          return Object.assign({}, state, {counter: state.counter + 1}); // returns new state based on action passed
      }
    }
  - Reducers must be pure funcitons and produce no side effects - calling it with the same arguments always returns the same predictable value.
  - Forbidden in Reducers:
    ~ Mutate arguments
    ~ Perform side effects, like API calls and routing transitions
    ~ Call non-pure functions, like date.now() or math.random()
  - Reducers can be nested:
    In Flux there can be multiple Stores, each one holding a different area of domain data. The downside is that one store needs to wait before
    the other one updates. This isn't necessary in Redux because the separation between data domains is achieved by splitting a single reducer
    into multiple smaller ones. It is technically possible to create multiple Stores in Redux, but it is not recommended and only useful rarely.
  - All Reducers are called on EACH dispatch - it is important for the Reducers to return the untouched state if no switch case matched.
    Each Reducer only handles its slice of state.
  - Redux FAQ: "Write independent small reducer functions that are each responsible for updates to a specific slice of state.
    We call this pattern "reducer composition". A given action could be handled by all, some, or none of them."
    In other there shouldn't always be a 1:1 mapping between Reducers and Actions.



7. Connecting React to Redux
===================




Appendix: ES6
===================

* 'var' is to be avoided, but 'let' and 'const' are to be used.
  'const' is more strict and doesn't allow the variable to be reassigned a different value.

* The arrow function syntax '(...) => { ... }' is used insted of traditional 'function(...) { ... }' syntax and it is a matter of taste.

* A new approach to clone an object in JavaScript is to use Object.assign().
  This method creates a new object, but allows to specify existing objects as a template.
  Signature: Object.assign(target, ...sources)
  Example:   Object.assign({}, state, {role: 'admin'});
  A new object is created '{}', then it is mixed with the 'state' object and then with the anonymous object, which changes the 'role' property.
  It is important for the 1st parameter to be an empty object, as otherwise the 'state' would be mutated.
  Not all browsers yet support Object.assign() and Babel doesn't transpile it, so 'babel-polyfill' must be included at the root of the app (index.js).

* Spread operator (...)
